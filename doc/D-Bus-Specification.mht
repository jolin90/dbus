From: =?iso-8859-1?B?0tHTySBJbnRlcm5ldCBFeHBsb3JlciAxMSCxo7Tm?=
Subject: D-Bus Specification
Date: Mon, 11 Aug 2014 11:27:23 +0800
MIME-Version: 1.0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://dbus.freedesktop.org/doc/dbus-specification.html
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7601.17609

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><META content=3D"IE=3D5.0000" =
http-equiv=3D"X-UA-Compatible">

<META http-equiv=3D"Content-Type"=20
content=3D"text/html; charset=3DISO-8859-1"><TITLE>D-Bus =
Specification</TITLE>
<META name=3D"GENERATOR" content=3D"MSHTML 11.00.9600.17207"></HEAD>
<BODY text=3D"black" bgcolor=3D"white" link=3D"#0000ff" =
alink=3D"#0000ff" vlink=3D"#840084">
<DIV class=3D"article">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title"><A name=3D"index"></A>D-Bus Specification</H2></DIV>
<DIV>
<DIV class=3D"authorgroup">
<DIV class=3D"author">
<H3 class=3D"author"><SPAN class=3D"firstname">Havoc</SPAN> <SPAN=20
class=3D"surname">Pennington</SPAN></H3>
<DIV class=3D"affiliation"><SPAN class=3D"orgname">Red Hat, =
Inc.<BR></SPAN>
<DIV class=3D"address">
<P><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=
CODE=20
class=3D"email">&lt;<A class=3D"email"=20
href=3D"mailto:hp@pobox.com">hp@pobox.com</A>&gt;</CODE><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></DIV></D=
IV></DIV>
<DIV class=3D"author">
<H3 class=3D"author"><SPAN class=3D"firstname">Anders</SPAN> <SPAN=20
class=3D"surname">Carlsson</SPAN></H3>
<DIV class=3D"affiliation"><SPAN class=3D"orgname">CodeFactory =
AB<BR></SPAN>
<DIV class=3D"address">
<P><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=
CODE=20
class=3D"email">&lt;<A class=3D"email"=20
href=3D"mailto:andersca@codefactory.se">andersca@codefactory.se</A>&gt;</=
CODE><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></DIV></D=
IV></DIV>
<DIV class=3D"author">
<H3 class=3D"author"><SPAN class=3D"firstname">Alexander</SPAN> <SPAN =
class=3D"surname">Larsson</SPAN></H3>
<DIV class=3D"affiliation"><SPAN class=3D"orgname">Red Hat, =
Inc.<BR></SPAN>
<DIV class=3D"address">
<P><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=
CODE=20
class=3D"email">&lt;<A class=3D"email"=20
href=3D"mailto:alexl@redhat.com">alexl@redhat.com</A>&gt;</CODE><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></DIV></D=
IV></DIV>
<DIV class=3D"author">
<H3 class=3D"author"><SPAN class=3D"firstname">Sven</SPAN> <SPAN=20
class=3D"surname">Herzberg</SPAN></H3>
<DIV class=3D"affiliation"><SPAN class=3D"orgname">Imendio AB<BR></SPAN>
<DIV class=3D"address">
<P><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=
CODE=20
class=3D"email">&lt;<A class=3D"email"=20
href=3D"mailto:sven@imendio.com">sven@imendio.com</A>&gt;</CODE><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></DIV></D=
IV></DIV>
<DIV class=3D"author">
<H3 class=3D"author"><SPAN class=3D"firstname">Simon</SPAN> <SPAN=20
class=3D"surname">McVittie</SPAN></H3>
<DIV class=3D"affiliation"><SPAN class=3D"orgname">Collabora =
Ltd.<BR></SPAN>
<DIV class=3D"address">
<P><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=
CODE=20
class=3D"email">&lt;<A class=3D"email"=20
href=3D"mailto:simon.mcvittie@collabora.co.uk">simon.mcvittie@collabora.c=
o.uk</A>&gt;</CODE><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></DIV></D=
IV></DIV>
<DIV class=3D"author">
<H3 class=3D"author"><SPAN class=3D"firstname">David</SPAN> <SPAN=20
class=3D"surname">Zeuthen</SPAN></H3>
<DIV class=3D"affiliation">
<DIV class=3D"address">
<P><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<=
CODE=20
class=3D"email">&lt;<A class=3D"email"=20
href=3D"mailto:zeuthen@gmail.com">zeuthen@gmail.com</A>&gt;</CODE><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P></DIV></D=
IV></DIV></DIV></DIV>
<DIV>
<P class=3D"releaseinfo">Version 0.23</P></DIV>
<DIV>
<DIV class=3D"revhistory">
<TABLE style=3D"border-style: solid; width: 100%;" summary=3D"Revision =
History">
  <TBODY>
  <TR>
    <TH align=3D"left" valign=3D"top" colspan=3D"3"><B>Revision =
History</B></TH></TR>
  <TR>
    <TD align=3D"left">Revision 0.23</TD>
    <TD align=3D"left">2014-01-06</TD>
    <TD align=3D"left">SMcV, CY</TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">         method call messages with =
no=20
      INTERFACE may be considered an error;         document =
tcp:bind=3D... and=20
      nonce-tcp:bind=3D...; define listenable         and connectable =
addresses   =20
          </TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.22</TD>
    <TD align=3D"left">2013-10-09</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">add GetConnectionCredentials, =
document       =20
      GetAtdAuditSessionData, document =
GetConnectionSELinuxSecurityContext,     =20
        document and correct .service file syntax and naming       =
</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.21</TD>
    <TD align=3D"left">2013-04-25</TD>
    <TD align=3D"left">smcv</TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">allow Unicode noncharacters in =
UTF-8 (Unicode=20
              Corrigendum #9)</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.20</TD>
    <TD align=3D"left">22 February 2013</TD>
    <TD align=3D"left">smcv, walters</TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">reorganise for clarity, remove =
false claims=20
      about         basic types, mention /o/fd/DBus</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.19</TD>
    <TD align=3D"left">20 February 2012</TD>
    <TD align=3D"left">smcv/lp</TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">formally define unique connection =
names and=20
      well-known        bus names; document best practices for =
interface, bus,=20
      member and        error names, and object paths; document the =
search path=20
      for session        and system services on Unix; document the =
systemd=20
      transport</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.18</TD>
    <TD align=3D"left">29 July 2011</TD>
    <TD align=3D"left">smcv</TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">define eavesdropping, unicast, =
broadcast; add=20
      eavesdrop         match keyword; promote type system to a =
top-level=20
    section</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.17</TD>
    <TD align=3D"left">1 June 2011</TD>
    <TD align=3D"left">smcv/davidz</TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">define ObjectManager; reserve extra =

      pseudo-type-codes used         by GVariant</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.16</TD>
    <TD align=3D"left">11 April 2011</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">add path_namespace, arg0namespace; =
argNpath=20
      matches object        paths</TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.15</TD>
    <TD align=3D"left">3 November 2010</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.14</TD>
    <TD align=3D"left">12 May 2010</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.13</TD>
    <TD align=3D"left">23 Dezember 2009</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.12</TD>
    <TD align=3D"left">7 November, 2006</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.11</TD>
    <TD align=3D"left">6 February 2005</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.10</TD>
    <TD align=3D"left">28 January 2005</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.9</TD>
    <TD align=3D"left">7 Januar 2005</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3"></TD></TR>
  <TR>
    <TD align=3D"left">Revision 0.8</TD>
    <TD align=3D"left">06 September 2003</TD>
    <TD align=3D"left"></TD></TR>
  <TR>
    <TD align=3D"left" colspan=3D"3">First released=20
document.</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<HR>
</DIV>
<DIV class=3D"toc">
<P><B>Table of Contents</B></P>
<DL class=3D"toc">
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#introduct=
ion">Introduction</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#stability=
">Protocol=20
    and Specification Stability</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#type-syst=
em">Type=20
  System</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#basic-typ=
es">Basic=20
    types</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#container=
-types">Container=20
    types</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp556449=
12">Summary=20
    of types</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-marshaling">Marshaling=20
  (Wire Format)</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp556938=
72">Byte=20
    order and alignment</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp556996=
16">Marshalling=20
    basic types</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp557045=
60">Marshalling=20
    containers</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp557129=
28">Summary=20
    of D-Bus marshalling</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol">Message=20
  Protocol</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-messages">Message=20
    Format</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names">Valid=20
    Names</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-types">Message=20
    Types</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-handling-invalid">Invalid=20
    Protocol and Spec Extensions</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-prot=
ocol">Authentication=20
  Protocol</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-prot=
ocol-overview">Protocol=20
    Overview</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-nul-=
byte">Special=20
    credentials-passing nul byte</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-auth">AUTH=20
    command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-cancel">CANCEL=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-data">DATA=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-begin">BEGIN=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-rejected">REJECTED=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-ok">OK=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-error">ERROR=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-negotiate-unix-fd">NEGOTIATE_UNIX_FD=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-agree-unix-fd">AGREE_UNIX_FD=20
    Command</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-comm=
and-future">Future=20
    Extensions</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-exam=
ples">Authentication=20
    examples</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-stat=
es">Authentication=20
    state diagrams</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-mech=
anisms">Authentication=20
    mechanisms</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#addresses=
">Server=20
  Addresses</A></SPAN></DT>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s">Transports</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s-unix-domain-sockets">Unix=20
    Domain Sockets</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s-launchd">launchd</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s-systemd">systemd</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s-tcp-sockets">TCP=20
    Sockets</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s-nonce-tcp-sockets">Nonce-secured=20
    TCP Sockets</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#transport=
s-exec">Executed=20
    Subprocesses on Unix</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#meta-tran=
sports">Meta=20
  Transports</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#meta-tran=
sports-autolaunch">Autolaunch</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#uuids">UU=
IDs</A></SPAN></DT>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces">Standard=20
  Interfaces</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-peer"><CODE=20
    class=3D"literal">org.freedesktop.DBus.Peer</CODE></A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-introspectable"><CODE=20
    =
class=3D"literal">org.freedesktop.DBus.Introspectable</CODE></A></SPAN></=
DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-properties"><CODE=20
    =
class=3D"literal">org.freedesktop.DBus.Properties</CODE></A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-objectmanager"><CODE=20
    =
class=3D"literal">org.freedesktop.DBus.ObjectManager</CODE></A></SPAN></D=
T></DL></DD>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#introspec=
tion-format">Introspection=20
  Data Format</A></SPAN></DT>
  <DT><SPAN class=3D"sect1"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us">Message=20
  Bus Specification</A></SPAN></DT>
  <DD>
  <DL>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-overview">Message=20
    Bus Overview</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-names">Message=20
    Bus Names</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing">Message=20
    Bus Message Routing</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-starting-services">Message=20
    Bus Starting Services</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-types">Well-known=20
    Message Bus Instances</A></SPAN></DT>
    <DT><SPAN class=3D"sect2"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-messages">Message=20
    Bus Messages</A></SPAN></DT></DL></DD>
  <DT><SPAN class=3D"glossary"><A =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp568212=
48">Glossary</A></SPAN></DT></DL></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"introduction"></A>Introduction</H2></DIV></DIV></DIV>
<P>      D-Bus is a system for low-overhead, easy to use      =
interprocess=20
communication (IPC). In more detail:       </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>            D-Bus is <SPAN =
class=3D"emphasis"><EM>low-overhead</EM></SPAN>=20
  because it uses a            binary protocol, and does not have to =
convert to=20
  and from a text            format such as XML. Because D-Bus is =
intended for=20
  potentially            high-resolution same-machine IPC, not primarily =
for=20
  Internet IPC,            this is an interesting optimization. D-Bus is =
also=20
  designed to            avoid round trips and allow asynchronous =
operation,=20
  much like            the X protocol.           </P></LI>
  <LI class=3D"listitem">
  <P>            D-Bus is <SPAN class=3D"emphasis"><EM>easy to =
use</EM></SPAN>=20
  because it works in terms            of <EM =
class=3D"firstterm">messages</EM>=20
  rather than byte streams, and            automatically handles a lot =
of the=20
  hard IPC issues. Also, the D-Bus            library is designed to be =
wrapped=20
  in a way that lets developers use            their framework's =
existing=20
  object/type system, rather than learning            a new one =
specifically for=20
  IPC.           </P></LI></UL></DIV>
<P></P>
<P>      The base D-Bus protocol is a one-to-one (peer-to-peer or =
client-server)=20
     protocol, specified in <A title=3D"Message Protocol" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol">the=20
section called =93Message Protocol=94</A>. That is, it is      a system =
for one=20
application to talk to a single other      application. However, the =
primary=20
intended application of the protocol is the      D-Bus <EM=20
class=3D"firstterm">message bus</EM>, specified in <A title=3D"Message =
Bus Specification"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us">the=20
section called =93Message Bus Specification=94</A>. The message bus is a =
special=20
application that      accepts connections from multiple other =
applications, and=20
forwards      messages among them.     </P>
<P>      Uses of D-Bus include notification of system changes =
(notification of=20
when      a camera is plugged in to a computer, or a new version of some =

software      has been installed), or desktop interoperability, for =
example a=20
file      monitoring service or a configuration service.     </P>
<P>      D-Bus is designed for two specific use cases:       </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>            A "system bus" for notifications from the system to =
user=20
  sessions,            and to allow the system to request input from =
user=20
  sessions.           </P></LI>
  <LI class=3D"listitem">
  <P>            A "session bus" used to implement desktop environments =
such as =20
             GNOME and KDE.           </P></LI></UL></DIV>
<P>      D-Bus is not intended to be a generic IPC system for any =
possible      =20
application, and intentionally omits many features found in other       =
IPC=20
systems for this reason.     </P>
<P>      At the same time, the bus daemons offer a number of features =
not found=20
in      other IPC systems, such as single-owner "bus names" (similar to =
X     =20
selections), on-demand startup of services, and security policies.      =
In many=20
ways, these features are the primary motivation for developing       =
D-Bus;=20
other systems would have sufficed if IPC were the only goal.     </P>
<P>      D-Bus may turn out to be useful in unanticipated applications, =
but=20
future      versions of this spec and the reference implementation =
probably will=20
not      incorporate features that interfere with the core use cases.    =
 </P>
<P>      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL =
NOT",    =20
 "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this    =
 =20
document are to be interpreted as described in RFC 2119. However, the    =
 =20
document could use a serious audit to be sure it makes sense to do      =
so.=20
Also, they are not capitalized.     </P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"stability"></A>Protocol and Specification =

Stability</H3></DIV></DIV></DIV>
<P>        The D-Bus protocol is frozen (only compatible extensions are =
allowed)=20
as        of November 8, 2006.  However, this specification could still =
use a=20
fair        bit of work to make interoperable reimplementation possible =
without =20
      reference to the D-Bus reference implementation. Thus, this        =

specification is not marked 1.0. To mark it 1.0, we'd like to see        =
someone=20
invest significant effort in clarifying the specification        =
language, and=20
growing the specification to cover more aspects of the        reference=20
implementation's behavior.       </P>
<P>        Until this work is complete, any attempt to reimplement D-Bus =
will   =20
     probably require looking at the reference implementation and/or =
asking     =20
  questions on the D-Bus mailing list about intended behavior.         =
Questions=20
on the list are very welcome.       </P>
<P>        Nonetheless, this document should be a useful starting point =
and is  =20
      to our knowledge accurate, though incomplete.       =
</P></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A =
name=3D"type-system"></A>Type=20
System</H2></DIV></DIV></DIV>
<P>      D-Bus has a type system, in which values of various types can =
be     =20
serialized into a sequence of bytes referred to as the       <EM =
class=3D"firstterm">wire=20
format</EM> in a standard way.      Converting a value from some other=20
representation into the wire      format is called <EM=20
class=3D"firstterm">marshaling</EM> and converting      it back from the =
wire=20
format is <EM class=3D"firstterm">unmarshaling</EM>.     </P>
<P>      The D-Bus protocol does not include type tags in the marshaled =
data; a =20
    block of marshaled values must have a known <EM =
class=3D"firstterm">type      =20
 signature</EM>. The type signature is made up of zero or more       <EM =
class=3D"firstterm"><A=20
name=3D"term-single-complete-type"></A>single complete        =
types</EM>, each=20
made up of one or more       <EM class=3D"firstterm">type codes</EM>.    =
 </P>
<P>      A type code is an ASCII character representing the      type of =
a=20
value. Because ASCII characters are used, the type signature      will =
always=20
form a valid ASCII string. A simple string compare      determines =
whether two=20
type signatures are equivalent.     </P>
<P>      A single complete type is a sequence of type codes that fully =
describes=20
     one type: either a basic type, or a single fully-described =
container type. =20
    A single complete type is a basic type code, a variant type code,    =
  an=20
array with its element type, or a struct with its fields (all of which   =
   are=20
defined below). So the following signatures are not single complete      =
types: =20
     </P>
<PRE class=3D"programlisting">        "aa"=0A=
      </PRE>
<P></P>
<PRE class=3D"programlisting">        "(ii"=0A=
      </PRE>
<P></P>
<PRE class=3D"programlisting">        "ii)"=0A=
      </PRE>
<P>      And the following signatures contain multiple complete types:   =
   =20
</P>
<PRE class=3D"programlisting">        "ii"=0A=
      </PRE>
<P></P>
<PRE class=3D"programlisting">        "aiai"=0A=
      </PRE>
<P></P>
<PRE class=3D"programlisting">        "(ii)(ii)"=0A=
      </PRE>
<P>      Note however that a single complete type may <SPAN=20
class=3D"emphasis"><EM>contain</EM></SPAN>      multiple other single =
complete=20
types, by containing a struct or dict      entry.     </P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"basic-types"></A>Basic =
types</H3></DIV></DIV></DIV>
<P>        The simplest type codes are the <EM class=3D"firstterm"><A =
name=3D"term-basic-type"></A>basic=20
         types</EM>, which are the types whose structure is entirely     =
  =20
defined by their 1-character type code. Basic types consist of        =
fixed=20
types and string-like types.       </P>
<P>        The <EM class=3D"firstterm"><A =
name=3D"term-fixed-type"></A>fixed=20
types</EM>        are basic types whose values have a fixed length, =
namely BYTE,=20
       BOOLEAN, DOUBLE, UNIX_FD, and signed or unsigned integers of =
length      =20
 16, 32 or 64 bits.       </P>
<P>        As a simple example, the type code for 32-bit integer (<CODE =
class=3D"literal">INT32</CODE>)=20
is        the ASCII character 'i'. So the signature for a block of =
values       =20
 containing a single <CODE class=3D"literal">INT32</CODE> would be:      =
   </P>
<PRE class=3D"programlisting">          "i"=0A=
        </PRE>
<P>        A block of values containing two <CODE =
class=3D"literal">INT32</CODE>=20
would have this signature:         </P>
<PRE class=3D"programlisting">          "ii"=0A=
        </PRE>
<P></P>
<P>        The characteristics of the fixed types are listed in this =
table.     =20
   </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional name</TH>
    <TH>ASCII type-code</TH>
    <TH>Encoding</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">BYTE</CODE></TD>
    <TD><CODE class=3D"literal">y</CODE> (121)</TD>
    <TD>Unsigned 8-bit integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">BOOLEAN</CODE></TD>
    <TD><CODE class=3D"literal">b</CODE> (98)</TD>
    <TD>Boolean value: 0 is false, 1 is true, any other value            =
     =20
      allowed by the marshalling format is invalid</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT16</CODE></TD>
    <TD><CODE class=3D"literal">n</CODE> (110)</TD>
    <TD>Signed (two's complement) 16-bit integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT16</CODE></TD>
    <TD><CODE class=3D"literal">q</CODE> (113)</TD>
    <TD>Unsigned 16-bit integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT32</CODE></TD>
    <TD><CODE class=3D"literal">i</CODE> (105)</TD>
    <TD>Signed (two's complement) 32-bit integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT32</CODE></TD>
    <TD><CODE class=3D"literal">u</CODE> (117)</TD>
    <TD>Unsigned 32-bit integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT64</CODE></TD>
    <TD><CODE class=3D"literal">x</CODE> (120)</TD>
    <TD>Signed (two's complement) 64-bit integer                  =
(mnemonic: x=20
      and t are the first characters in "sixty" not                  =
already=20
      used for something more common)</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT64</CODE></TD>
    <TD><CODE class=3D"literal">t</CODE> (116)</TD>
    <TD>Unsigned 64-bit integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">DOUBLE</CODE></TD>
    <TD><CODE class=3D"literal">d</CODE> (100)</TD>
    <TD>IEEE 754 double-precision floating point</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UNIX_FD</CODE></TD>
    <TD><CODE class=3D"literal">h</CODE> (104)</TD>
    <TD>Unsigned 32-bit integer representing an index into an            =
     =20
      out-of-band array of file descriptors, transferred via some        =
       =20
        platform-specific mechanism (mnemonic: h for=20
handle)</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>        The <EM class=3D"firstterm"><A=20
name=3D"term-string-like-type"></A>string-like types</EM>        are =
basic types=20
with a variable length. The value of any string-like        type is =
conceptually=20
0 or more Unicode codepoints encoded in UTF-8,        none of which may =
be=20
U+0000. The UTF-8 text must be validated        strictly: in particular, =
it must=20
not contain overlong sequences        or codepoints above U+10FFFF.      =
 </P>
<P>        Since D-Bus Specification version 0.21, in accordance with =
Unicode   =20
    Corrigendum #9, the "noncharacters" U+FDD0..U+FDEF, U+nFFFE and      =
 =20
U+nFFFF are allowed in UTF-8 strings (but note that older versions of    =
   =20
D-Bus rejected these noncharacters).       </P>
<P>        The marshalling formats for the string-like types all end =
with a     =20
  single zero (NUL) byte, but that byte is not considered to be part of  =
     =20
the text.       </P>
<P>        The characteristics of the string-like types are listed in =
this=20
table.         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional name</TH>
    <TH>ASCII type-code</TH>
    <TH>Validity constraints</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD><CODE class=3D"literal">s</CODE> (115)</TD>
    <TD>No extra constraints</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">OBJECT_PATH</CODE></TD>
    <TD><CODE class=3D"literal">o</CODE> (111)</TD>
    <TD>Must be                   <A title=3D"Valid Object Paths" =
class=3D"link"=20
      =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-marshaling-object-path">a=20
                         syntactically valid object path</A></TD></TR>
  <TR>
    <TD><CODE class=3D"literal">SIGNATURE</CODE></TD>
    <TD><CODE class=3D"literal">g</CODE> (103)</TD>
    <TD>Zero or more                   <A class=3D"firstterm" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-sing=
le-complete-type"><EM=20
      class=3D"firstterm">single                    complete=20
  types</EM></A></TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-protocol-marshaling-object-path"></A>Valid=20
Object Paths</H4></DIV></DIV></DIV>
<P>          An object path is a name used to refer to an object =
instance.      =20
   Conceptually, each participant in a D-Bus message exchange may have   =
      =20
any number of object instances (think of C++ or Java objects) and each   =
      =20
such instance will have a path. Like a filesystem, the object          =
instances=20
in an application form a hierarchical tree.         </P>
<P>          Object paths are often namespaced by starting with a =
reversed      =20
   domain name and containing an interface version number, in the        =
  same=20
way as           <A title=3D"Interface names" class=3D"link" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-interface">interface=20
           names</A> and           <A title=3D"Bus names" class=3D"link" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-bus">well-known=20
           bus names</A>.          This makes it possible to implement =
more than=20
one service, or          more than one version of a service, in the same =

process,          even if the services share a connection but cannot =
otherwise  =20
       co-operate (for instance, if they are implemented by different    =
     =20
plugins).         </P>
<P>          For instance, if the owner of <CODE=20
class=3D"literal">example.com</CODE> is          developing a D-Bus API =
for a=20
music player, they might use the          hierarchy of object paths that =
start=20
with           <CODE class=3D"literal">/com/example/MusicPlayer1</CODE> =
for its=20
objects.         </P>
<P>          The following rules define a valid object path. =
Implementations=20
must          not send or accept messages with invalid object paths.     =
     =20
</P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                The path may be of any length.               =
</P></LI>
  <LI class=3D"listitem">
  <P>                The path must begin with an ASCII '/' (integer 47)=20
  character,                and must consist of elements separated by =
slash=20
  characters.               </P></LI>
  <LI class=3D"listitem">
  <P>                Each element must only contain the ASCII characters =
       =20
         "[A-Z][a-z][0-9]_"               </P></LI>
  <LI class=3D"listitem">
  <P>                No element may be the empty string.               =
</P></LI>
  <LI class=3D"listitem">
  <P>                Multiple '/' characters cannot occur in sequence.   =
       =20
      </P></LI>
  <LI class=3D"listitem">
  <P>                A trailing '/' character is not allowed unless the  =
       =20
        path is the root path (a single '/' character).              =20
</P></LI></UL></DIV>
<P></P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-protocol-marshaling-signature"></A>Valid=20
Signatures</H4></DIV></DIV></DIV>
<P>          An implementation must not send or accept invalid =
signatures.      =20
   Valid signatures will conform to the following rules:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                The signature is a list of single complete types.   =
       =20
       Arrays must have element types, and structs must                =
have both=20
  open and close parentheses.               </P></LI>
  <LI class=3D"listitem">
  <P>                Only type codes, open and close parentheses, and =
open and  =20
               close curly brackets are allowed in the signature. The    =
       =20
       <CODE class=3D"literal">STRUCT</CODE> type code                is =
not=20
  allowed in signatures, because parentheses                are used =
instead.=20
  Similarly, the                 <CODE =
class=3D"literal">DICT_ENTRY</CODE> type=20
  code is not allowed in                signatures, because curly =
brackets are=20
  used instead.               </P></LI>
  <LI class=3D"listitem">
  <P>                The maximum depth of container type nesting is 32 =
array=20
  type                codes and 32 open parentheses. This implies that =
the=20
  maximum                total depth of recursion is 64, for an "array =
of array=20
  of array                of ... struct of struct of struct of ..."  =
where there=20
  are 32                array and 32 struct.               </P></LI>
  <LI class=3D"listitem">
  <P>                The maximum length of a signature is 255.           =
   =20
  </P></LI></UL></DIV>
<P></P>
<P>          When signatures appear in messages, the marshalling format  =
       =20
guarantees that they will be followed by a nul byte (which can          =
be=20
interpreted as either C-style string termination or the INVALID          =

type-code), but this is not conceptually part of the signature.        =20
</P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"container-types"></A>Container=20
types</H3></DIV></DIV></DIV>
<P>        In addition to basic types, there are four <EM=20
class=3D"firstterm">container</EM>         types: <CODE=20
class=3D"literal">STRUCT</CODE>, <CODE class=3D"literal">ARRAY</CODE>, =
<CODE class=3D"literal">VARIANT</CODE>,=20
        and <CODE class=3D"literal">DICT_ENTRY</CODE>.       </P>
<P><CODE class=3D"literal">STRUCT</CODE> has a type code, ASCII =
character 'r', but=20
this type         code does not appear in signatures. Instead, ASCII =
characters =20
      '(' and ')' are used to mark the beginning and end of the struct.  =
     =20
So for example, a struct containing two integers would have this         =

signature:         </P>
<PRE class=3D"programlisting">          "(ii)"=0A=
        </PRE>
<P>        Structs can be nested, so for example a struct containing     =
    an=20
integer and another struct:         </P>
<PRE class=3D"programlisting">          "(i(ii))"=0A=
        </PRE>
<P>        The value block storing that struct would contain three =
integers; the=20
       type signature allows you to distinguish "(i(ii))" from "((ii)i)" =
or     =20
  "(iii)" or "iii".       </P>
<P>        The <CODE class=3D"literal">STRUCT</CODE> type code 'r' is =
not=20
currently used in the D-Bus protocol,        but is useful in code that=20
implements the protocol. This type code         is specified to allow =
such code=20
to interoperate in non-protocol contexts.       </P>
<P>        Empty structures are not allowed; there must be at least one  =
     =20
type code between the parentheses.       </P>
<P><CODE class=3D"literal">ARRAY</CODE> has ASCII character 'a' as type =
code. The=20
array type code must be        followed by a <EM =
class=3D"firstterm">single=20
complete type</EM>. The single        complete type following the array =
is the=20
type of each array element. So        the simple example is:         =
</P>
<PRE class=3D"programlisting">          "ai"=0A=
        </PRE>
<P>        which is an array of 32-bit integers. But an array can be of =
any=20
type,         such as this array-of-struct-with-two-int32-fields:        =
 </P>
<PRE class=3D"programlisting">          "a(ii)"=0A=
        </PRE>
<P>        Or this array of array of integer:         </P>
<PRE class=3D"programlisting">          "aai"=0A=
        </PRE>
<P></P>
<P><CODE class=3D"literal">VARIANT</CODE> has ASCII character 'v' as its =
type=20
code. A marshaled value of        type <CODE =
class=3D"literal">VARIANT</CODE> will=20
have the signature of a single complete type as part        of the <SPAN =
class=3D"emphasis"><EM>value</EM></SPAN>.=20
 This signature will be followed by a        marshaled value of that =
type.      =20
</P>
<P>        Unlike a message signature, the variant signature can        =
contain=20
only a single complete type.  So "i", "ai"        or "(ii)" is OK, but =
"ii" is=20
not.  Use of variants may not        cause a total message depth to be =
larger=20
than 64, including        other container types such as structures.      =
 </P>
<P>        A <CODE class=3D"literal">DICT_ENTRY</CODE> works exactly =
like a=20
struct, but rather        than parentheses it uses curly braces, and it =
has more=20
restrictions.        The restrictions are: it occurs only as an array =
element=20
type; it has        exactly two single complete types inside the curly =
braces;=20
the first        single complete type (the "key") must be a basic type =
rather=20
than a        container type. Implementations must not accept dict =
entries=20
outside of        arrays, must not accept dict entries with zero, one, =
or more=20
than two        fields, and must not accept dict entries with =
non-basic-typed=20
keys. A        dict entry is always a key-value pair.       </P>
<P>        The first field in the <CODE =
class=3D"literal">DICT_ENTRY</CODE> is=20
always the key.        A message is considered corrupt if the same key =
occurs=20
twice in the same        array of <CODE =
class=3D"literal">DICT_ENTRY</CODE>.=20
However, for performance reasons        implementations are not required =
to=20
reject dicts with duplicate keys.       </P>
<P>        In most languages, an array of dict entry would be =
represented as a  =20
      map, hash table, or dict object.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"idp55644912"></A>Summary of=20
types</H3></DIV></DIV></DIV>
<P>        The following table summarizes the D-Bus types.         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional Name</TH>
    <TH>Code</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">INVALID</CODE></TD>
    <TD>0 (ASCII NUL)</TD>
    <TD>Not a valid type code, used to terminate signatures</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">BYTE</CODE></TD>
    <TD>121 (ASCII 'y')</TD>
    <TD>8-bit unsigned integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">BOOLEAN</CODE></TD>
    <TD>98 (ASCII 'b')</TD>
    <TD>Boolean value, 0 is <CODE class=3D"literal">FALSE</CODE> and 1 =
is <CODE=20
      class=3D"literal">TRUE</CODE>. Everything else is =
invalid.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT16</CODE></TD>
    <TD>110 (ASCII 'n')</TD>
    <TD>16-bit signed integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT16</CODE></TD>
    <TD>113 (ASCII 'q')</TD>
    <TD>16-bit unsigned integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT32</CODE></TD>
    <TD>105 (ASCII 'i')</TD>
    <TD>32-bit signed integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT32</CODE></TD>
    <TD>117 (ASCII 'u')</TD>
    <TD>32-bit unsigned integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT64</CODE></TD>
    <TD>120 (ASCII 'x')</TD>
    <TD>64-bit signed integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT64</CODE></TD>
    <TD>116 (ASCII 't')</TD>
    <TD>64-bit unsigned integer</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">DOUBLE</CODE></TD>
    <TD>100 (ASCII 'd')</TD>
    <TD>IEEE 754 double</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD>115 (ASCII 's')</TD>
    <TD>UTF-8 string (<SPAN class=3D"emphasis"><EM>must</EM></SPAN> be =
valid=20
      UTF-8). Must be nul terminated and contain no other nul =
bytes.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">OBJECT_PATH</CODE></TD>
    <TD>111 (ASCII 'o')</TD>
    <TD>Name of an object instance</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">SIGNATURE</CODE></TD>
    <TD>103 (ASCII 'g')</TD>
    <TD>A type signature</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">ARRAY</CODE></TD>
    <TD>97 (ASCII 'a')</TD>
    <TD>Array</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">STRUCT</CODE></TD>
    <TD>114 (ASCII 'r'), 40 (ASCII '('), 41 (ASCII ')')</TD>
    <TD>Struct; type code 114 'r' is reserved for use in                 =
=20
      bindings and implementations to represent the general              =
   =20
      concept of a struct, and must not appear in signatures             =
    =20
      used on D-Bus.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">VARIANT</CODE></TD>
    <TD>118 (ASCII 'v') </TD>
    <TD>Variant type (the type of the value is part of the value =
itself)</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">DICT_ENTRY</CODE></TD>
    <TD>101 (ASCII 'e'), 123 (ASCII '{'), 125 (ASCII '}') </TD>
    <TD>Entry in a dict or map (array of key-value pairs).               =
  =20
      Type code 101 'e' is reserved for use in bindings and              =
   =20
      implementations to represent the general concept of a              =
   =20
      dict or dict-entry, and must not appear in signatures              =
   =20
      used on D-Bus.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UNIX_FD</CODE></TD>
    <TD>104 (ASCII 'h')</TD>
    <TD>Unix file descriptor</TD></TR>
  <TR>
    <TD>(reserved)</TD>
    <TD>109 (ASCII 'm')</TD>
    <TD>Reserved for <A class=3D"ulink" =
href=3D"https://bugs.freedesktop.org/show_bug.cgi?id=3D27857"=20
      target=3D"_top">a                  'maybe' type compatible with =
the one in=20
      GVariant</A>,                  and must not appear in signatures =
used on=20
      D-Bus until                  specified here</TD></TR>
  <TR>
    <TD>(reserved)</TD>
    <TD>42 (ASCII '*')</TD>
    <TD>Reserved for use in bindings/implementations to                  =

      represent any <EM class=3D"firstterm">single complete type</EM>,   =
         =20
           and must not appear in signatures used on D-Bus.</TD></TR>
  <TR>
    <TD>(reserved)</TD>
    <TD>63 (ASCII '?')</TD>
    <TD>Reserved for use in bindings/implementations to                  =

      represent any <EM class=3D"firstterm">basic type</EM>, and must    =
         =20
          not appear in signatures used on D-Bus.</TD></TR>
  <TR>
    <TD>(reserved)</TD>
    <TD>64 (ASCII '@'), 38 (ASCII '&amp;'),                  94 (ASCII =
'^')</TD>
    <TD>Reserved for internal use by bindings/implementations,           =
     =20
       and must not appear in signatures used on D-Bus.                  =

      GVariant uses these type-codes to encode calling                 =20
      conventions.</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"message-protocol-marshaling"></A>Marshaling (Wire=20
Format)</H2></DIV></DIV></DIV>
<P>      D-Bus defines a marshalling format for its type system, which =
is     =20
used in D-Bus messages. This is not the only possible marshalling      =
format=20
for the type system: for instance, GVariant (part of GLib)      re-uses =
the=20
D-Bus type system but implements an alternative marshalling      format. =
   =20
</P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"idp55693872"></A>Byte order and=20
alignment</H3></DIV></DIV></DIV>
<P>        Given a type signature, a block of bytes can be converted =
into typed =20
      values. This section describes the format of the block of bytes.  =
Byte    =20
   order and alignment issues are handled uniformly for all D-Bus types. =
     =20
</P>
<P>        A block of bytes has an associated byte order. The byte order =
      =20
has to be discovered in some way; for D-Bus messages, the        byte =
order is=20
part of the message header as described in         <A title=3D"Message =
Format"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-messages">the=20
section called =93Message Format=94</A>. For now, assume        that the =
byte order=20
is known to be either little endian or big          endian.       </P>
<P>        Each value in a block of bytes is aligned "naturally," for =
example   =20
    4-byte values are aligned to a 4-byte boundary, and 8-byte values to =
an     =20
  8-byte boundary. To properly align a value, <EM =
class=3D"firstterm">alignment   =20
    padding</EM> may be necessary. The alignment padding must always     =
   be=20
the minimum required padding to properly align the following value;      =
  and=20
it must always be made up of nul bytes. The alignment padding must       =
 not be=20
left uninitialized (it can't contain garbage), and more padding        =
than=20
required must not be used.       </P>
<P>        As an exception to natural alignment, <CODE=20
class=3D"literal">STRUCT</CODE> and         <CODE=20
class=3D"literal">DICT_ENTRY</CODE> values are always aligned to an =
8-byte       =20
boundary, regardless of the alignments of their contents.       =
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"idp55699616"></A>Marshalling basic=20
types</H3></DIV></DIV></DIV>
<P>        To marshal and unmarshal fixed types, you simply read one =
value      =20
 from the data block corresponding to each type code in the signature.   =
    =20
All signed integer values are encoded in two's complement, DOUBLE        =
values=20
are IEEE 754 double-precision floating-point, and BOOLEAN        values =
are=20
encoded in 32 bits (of which only the least significant        bit is =
used).    =20
  </P>
<P>        The string-like types are all marshalled as a        =
fixed-length=20
unsigned integer <CODE class=3D"varname">n</CODE> giving the        =
length of the=20
variable part, followed by <CODE class=3D"varname">n</CODE>        =
nonzero bytes=20
of UTF-8 text, followed by a single zero (nul) byte        which is not=20
considered to be part of the text. The alignment        of the =
string-like type=20
is the same as the alignment of         <CODE =
class=3D"varname">n</CODE>.      =20
</P>
<P>        For the STRING and OBJECT_PATH types, <CODE =
class=3D"varname">n</CODE>=20
is        encoded in 4 bytes, leading to 4-byte alignment.        For =
the=20
SIGNATURE type, <CODE class=3D"varname">n</CODE> is encoded as a single  =
     =20
byte. As a result, alignment padding is never required before a       =20
SIGNATURE.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"idp55704560"></A>Marshalling=20
containers</H3></DIV></DIV></DIV>
<P>        Arrays are marshalled as a <CODE =
class=3D"literal">UINT32</CODE>       =20
 <CODE class=3D"varname">n</CODE> giving the length of the array data in =
bytes,   =20
    followed by alignment padding to the alignment boundary of the array =
      =20
element type, followed by the <CODE class=3D"varname">n</CODE> bytes of =
the       =20
array elements marshalled in sequence. <CODE class=3D"varname">n</CODE> =
does not  =20
     include the padding after the length, or any padding after the      =
  last=20
element.       </P>
<P>        For instance, if the current position in the message is a =
multiple   =20
    of 8 bytes and the byte-order is big-endian, an array containing =
only       =20
the 64-bit integer 5 would be marshalled as:         </P>
<PRE class=3D"screen">00 00 00 08               <EM =
class=3D"lineannotation"><SPAN class=3D"lineannotation">8 bytes of =
data</SPAN></EM>=0A=
00 00 00 00               <EM class=3D"lineannotation"><SPAN =
class=3D"lineannotation">padding to 8-byte boundary</SPAN></EM>=0A=
00 00 00 00  00 00 00 05  <EM class=3D"lineannotation"><SPAN =
class=3D"lineannotation">first element =3D 5</SPAN></EM>=0A=
        </PRE>
<P></P>
<P>        Arrays have a maximum length defined to be 2 to the 26th =
power or    =20
   67108864. Implementations must not send or accept arrays exceeding =
this      =20
 length.       </P>
<P>        Structs and dict entries are marshalled in the same way as =
their     =20
  contents, but their alignment is always to an 8-byte boundary,        =
even if=20
their contents would normally be less strictly aligned.       </P>
<P>        Variants are marshalled as the <CODE =
class=3D"literal">SIGNATURE</CODE>=20
of        the contents (which must be a single complete type), followed =
by a    =20
   marshalled value with the type given by that signature. The        =
variant=20
has the same 1-byte alignment as the signature, which means        that=20
alignment padding before a variant is never needed.        Use of =
variants may=20
not cause a total message depth to be larger        than 64, including =
other=20
container types such as structures.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"idp55712928"></A>Summary of D-Bus=20
marshalling</H3></DIV></DIV></DIV>
<P>        Given all this, the types are marshaled on the wire as =
follows:      =20
  </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional Name</TH>
    <TH>Encoding</TH>
    <TH>Alignment</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">INVALID</CODE></TD>
    <TD>Not applicable; cannot be marshaled.</TD>
    <TD>N/A</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">BYTE</CODE></TD>
    <TD>A single 8-bit byte.</TD>
    <TD>1</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">BOOLEAN</CODE></TD>
    <TD>As for <CODE class=3D"literal">UINT32</CODE>, but only 0 and 1 =
are valid=20
      values.</TD>
    <TD>4</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT16</CODE></TD>
    <TD>16-bit signed integer in the message's byte order.</TD>
    <TD>2</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT16</CODE></TD>
    <TD>16-bit unsigned integer in the message's byte order.</TD>
    <TD>2</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT32</CODE></TD>
    <TD>32-bit signed integer in the message's byte order.</TD>
    <TD>4</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT32</CODE></TD>
    <TD>32-bit unsigned integer in the message's byte order.</TD>
    <TD>4</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INT64</CODE></TD>
    <TD>64-bit signed integer in the message's byte order.</TD>
    <TD>8</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UINT64</CODE></TD>
    <TD>64-bit unsigned integer in the message's byte order.</TD>
    <TD>8</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">DOUBLE</CODE></TD>
    <TD>64-bit IEEE 754 double in the message's byte order.</TD>
    <TD>8</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD>A <CODE class=3D"literal">UINT32</CODE> indicating the string's  =
       =20
               length in bytes excluding its terminating nul, followed =
by       =20
                 non-nul string data of the given length, followed by a=20
      terminating nul                   byte.                 </TD>
    <TD>                  4 (for the length)                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">OBJECT_PATH</CODE></TD>
    <TD>Exactly the same as <CODE class=3D"literal">STRING</CODE> except =
the    =20
                    content must be a valid object path (see above).     =
       =20
          </TD>
    <TD>                  4 (for the length)                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">SIGNATURE</CODE></TD>
    <TD>The same as <CODE class=3D"literal">STRING</CODE> except the =
length is a=20
      single                   byte (thus signatures have a maximum =
length of=20
      255)                  and the content must be a valid signature =
(see=20
      above).                 </TD>
    <TD>                  1                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">ARRAY</CODE></TD>
    <TD>                  A <CODE class=3D"literal">UINT32</CODE> giving =
the=20
      length of the array data in bytes, followed by                   =
alignment=20
      padding to the alignment boundary of the array element type,       =
       =20
         followed by each array element.                 </TD>
    <TD>                  4 (for the length)                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">STRUCT</CODE></TD>
    <TD>                  A struct must start on an 8-byte boundary =
regardless=20
      of the                  type of the struct fields. The struct =
value=20
      consists of each                  field marshaled in sequence =
starting=20
      from that 8-byte                  alignment boundary.              =
   </TD>
    <TD>                  8                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">VARIANT</CODE></TD>
    <TD>                  The marshaled <CODE =
class=3D"literal">SIGNATURE</CODE>=20
      of a single                  complete type, followed by a =
marshaled value=20
      with the type                  given in the signature.             =
    </TD>
    <TD>                  1 (alignment of the signature)                 =

</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">DICT_ENTRY</CODE></TD>
    <TD>                  Identical to STRUCT.                 </TD>
    <TD>                  8                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UNIX_FD</CODE></TD>
    <TD>32-bit unsigned integer in the message's byte                =
order.=20
      The actual file descriptors need to be                transferred=20
      out-of-band via some platform specific                mechanism. =
On the=20
      wire, values of this type store the index to the                =
file=20
      descriptor in the array of file descriptors that                =
accompany=20
      the message.</TD>
    <TD>4</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A =
name=3D"message-protocol"></A>Message=20
Protocol</H2></DIV></DIV></DIV>
<P>      A <EM class=3D"firstterm">message</EM> consists of a       <EM =
class=3D"firstterm">header</EM>=20
and a <EM class=3D"firstterm">body</EM>. If you      think of a message =
as a=20
package, the header is the address, and the body      contains the =
package=20
contents. The message delivery system uses the header      information =
to figure=20
out where to send the message and how to interpret      it; the =
recipient=20
interprets the body of the message.     </P>
<P>      The body of the message is made up of zero or more       <EM =
class=3D"firstterm">arguments</EM>,=20
which are typed values, such as an      integer or a byte array.     =
</P>
<P>      Both header and body use the D-Bus <A title=3D"Type System" =
class=3D"link"=20
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#type-syst=
em">type =20
      system</A> and format for serializing data.     </P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-protocol-messages"></A>Message=20
Format</H3></DIV></DIV></DIV>
<P>        A message consists of a header and a body. The header is a =
block of  =20
     values with a fixed signature and meaning.  The body is a separate =
block   =20
    of values, with a signature specified in the header.       </P>
<P>        The length of the header must be a multiple of 8, allowing =
the body=20
to        begin on an 8-byte boundary when storing the entire message in =
a=20
single        buffer. If the header does not naturally end on an 8-byte =
boundary=20
        up to 7 bytes of nul-initialized alignment padding must be =
added.      =20
</P>
<P>        The message body need not end on an 8-byte boundary.       =
</P>
<P>        The maximum length of a message, including header, header =
alignment=20
padding,         and body is 2 to the 27th power or 134217728. =
Implementations=20
must not         send or accept messages exceeding this size.       </P>
<P>        The signature of the header is:         </P>
<PRE class=3D"programlisting">          "yyyyuua(yv)"=0A=
        </PRE>
<P>        Written out more readably, this is:         </P>
<PRE class=3D"programlisting">          BYTE, BYTE, BYTE, BYTE, UINT32, =
UINT32, ARRAY of STRUCT of (BYTE,VARIANT)=0A=
        </PRE>
<P></P>
<P>        These values have the following meanings:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>1st <CODE class=3D"literal">BYTE</CODE></TD>
    <TD>Endianness flag; ASCII 'l' for little-endian                   =
or=20
      ASCII 'B' for big-endian. Both header and body are                 =
in this=20
      endianness.</TD></TR>
  <TR>
    <TD>2nd <CODE class=3D"literal">BYTE</CODE></TD>
    <TD><EM class=3D"firstterm">Message type</EM>. Unknown types must be =

      ignored.                   Currently-defined types are described =
below.   =20
                   </TD></TR>
  <TR>
    <TD>3rd <CODE class=3D"literal">BYTE</CODE></TD>
    <TD>Bitwise OR of flags. Unknown flags                  must be =
ignored.=20
      Currently-defined flags are described below.                 =
</TD></TR>
  <TR>
    <TD>4th <CODE class=3D"literal">BYTE</CODE></TD>
    <TD>Major protocol version of the sending application.  If           =
    =20
      the major protocol version of the receiving application does not   =
       =20
           match, the applications will not be able to communicate and =
the      =20
               D-Bus connection must be disconnected. The major protocol =
       =20
             version for this version of the specification is 1.         =
       =20
    </TD></TR>
  <TR>
    <TD>1st <CODE class=3D"literal">UINT32</CODE></TD>
    <TD>Length in bytes of the message body, starting                   =
from=20
      the end of the header. The header ends after                   its =

      alignment padding to an 8-boundary.                 </TD></TR>
  <TR>
    <TD>2nd <CODE class=3D"literal">UINT32</CODE></TD>
    <TD>The serial of this message, used as a cookie                   =
by the=20
      sender to identify the reply corresponding                  to =
this=20
      request. This must not be zero.                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">ARRAY</CODE> of <CODE=20
      class=3D"literal">STRUCT</CODE> of (<CODE =
class=3D"literal">BYTE</CODE>,<CODE=20
      class=3D"literal">VARIANT</CODE>)</TD>
    <TD>An array of zero or more <EM class=3D"firstterm">header          =
       =20
      fields</EM> where the byte is the field code, and the              =
   =20
      variant is the field value. The message type determines            =
      =20
      which fields are required.                 =
</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P><EM class=3D"firstterm">Message types</EM> that can appear in the =
second byte  =20
     of the header are:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional name</TH>
    <TH>Decimal value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">INVALID</CODE></TD>
    <TD>0</TD>
    <TD>This is an invalid type.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">METHOD_CALL</CODE></TD>
    <TD>1</TD>
    <TD>Method call.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">METHOD_RETURN</CODE></TD>
    <TD>2</TD>
    <TD>Method reply with returned data.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">ERROR</CODE></TD>
    <TD>3</TD>
    <TD>Error reply. If the first argument exists and is a               =
=20
      string, it is an error message.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">SIGNAL</CODE></TD>
    <TD>4</TD>
    <TD>Signal emission.</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>        Flags that can appear in the third byte of the header:        =
 </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional name</TH>
    <TH>Hex value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">NO_REPLY_EXPECTED</CODE></TD>
    <TD>0x1</TD>
    <TD>This message does not expect method return replies or            =
   =20
      error replies; the reply can be omitted as an                =
optimization.=20
      However, it is compliant with this specification                to =
return=20
      the reply despite this flag and the only harm                   =
from doing=20
      so is extra network traffic.                 </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">NO_AUTO_START</CODE></TD>
    <TD>0x2</TD>
    <TD>The bus must not launch an owner                  for the =
destination=20
      name in response to this message.                =20
</TD></TR></TBODY></TABLE></DIV>
<P></P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-protocol-header-fields"></A>Header=20
Fields</H4></DIV></DIV></DIV>
<P>          The array at the end of the header contains <EM=20
class=3D"firstterm">header          fields</EM>, where each field is a =
1-byte=20
field code followed          by a field value. A header must contain the =

required header fields for          its message type, and zero or more =
of any=20
optional header          fields. Future versions of this protocol =
specification=20
may add new          fields. Implementations must ignore fields they do =
not     =20
    understand. Implementations must not invent their own header fields; =
       =20
 only changes to this specification may introduce new header fields.     =
   =20
</P>
<P>          Again, if an implementation sees a header field code that =
it does=20
not          expect, it must ignore that field, as it will be part of a =
new     =20
    (but compatible) version of this specification. This also applies    =
      =20
to known header fields appearing in unexpected messages, for           =
example:=20
if a signal has a reply serial it must be ignored          even though =
it has no=20
meaning as of this version of the spec.         </P>
<P>          However, implementations must not send or accept known =
header=20
fields          with the wrong type stored in the field value. So for =
example a =20
        message with an <CODE class=3D"literal">INTERFACE</CODE> field =
of type    =20
      <CODE class=3D"literal">UINT32</CODE> would be considered corrupt. =
       =20
</P>
<P>          Here are the currently-defined header fields:           =
</P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional Name</TH>
    <TH>Decimal Code</TH>
    <TH>Type</TH>
    <TH>Required In</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">INVALID</CODE></TD>
    <TD>0</TD>
    <TD>N/A</TD>
    <TD>not allowed</TD>
    <TD>Not a valid field name (error if it appears in a =
message)</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">PATH</CODE></TD>
    <TD>1</TD>
    <TD><CODE class=3D"literal">OBJECT_PATH</CODE></TD>
    <TD><CODE class=3D"literal">METHOD_CALL</CODE>, <CODE=20
      class=3D"literal">SIGNAL</CODE></TD>
    <TD>The object to send a call to,                    or the object a =

      signal is emitted from.                    The special path        =
       =20
           <CODE class=3D"literal">/org/freedesktop/DBus/Local</CODE> is =
reserved;=20
                         implementations should not send messages with =
this=20
      path,                    and the reference implementation of the =
bus=20
      daemon will                    disconnect any application that =
attempts to=20
      do so.                   </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">INTERFACE</CODE></TD>
    <TD>2</TD>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD><CODE class=3D"literal">SIGNAL</CODE></TD>
    <TD>                    The interface to invoke a method call on, or =
     =20
                    that a signal is emitted from. Optional for          =
       =20
         method calls, required for signals.                    The =
special=20
      interface                     <CODE=20
      class=3D"literal">org.freedesktop.DBus.Local</CODE> is reserved;   =
         =20
             implementations should not send messages with this          =
       =20
        interface, and the reference implementation of the bus           =
       =20
       daemon will disconnect any application that attempts to           =
       =20
       do so.                   </TD></TR>
  <TR>
    <TD><CODE class=3D"literal">MEMBER</CODE></TD>
    <TD>3</TD>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD><CODE class=3D"literal">METHOD_CALL</CODE>, <CODE=20
      class=3D"literal">SIGNAL</CODE></TD>
    <TD>The member, either the method name or signal name.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">ERROR_NAME</CODE></TD>
    <TD>4</TD>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD><CODE class=3D"literal">ERROR</CODE></TD>
    <TD>The name of the error that occurred, for errors</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">REPLY_SERIAL</CODE></TD>
    <TD>5</TD>
    <TD><CODE class=3D"literal">UINT32</CODE></TD>
    <TD><CODE class=3D"literal">ERROR</CODE>, <CODE=20
      class=3D"literal">METHOD_RETURN</CODE></TD>
    <TD>The serial number of the message this message is a reply         =
     =20
           to. (The serial number is the second <CODE=20
      class=3D"literal">UINT32</CODE> in the header.)</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">DESTINATION</CODE></TD>
    <TD>6</TD>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD>optional</TD>
    <TD>The name of the connection this message is intended for.         =
     =20
           Only used in combination with the message bus, see            =
       =20
        <A title=3D"Message Bus Specification" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us">the=20
      section called =93Message Bus Specification=94</A>.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">SENDER</CODE></TD>
    <TD>7</TD>
    <TD><CODE class=3D"literal">STRING</CODE></TD>
    <TD>optional</TD>
    <TD>Unique name of the sending connection.                    The =
message=20
      bus fills in this field so it is reliable; the field is            =
       =20
      only meaningful in combination with the message bus.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">SIGNATURE</CODE></TD>
    <TD>8</TD>
    <TD><CODE class=3D"literal">SIGNATURE</CODE></TD>
    <TD>optional</TD>
    <TD>The signature of the message body.                  If omitted, =
it is=20
      assumed to be the                   empty signature "" (i.e. the =
body must=20
      be 0-length).</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">UNIX_FDS</CODE></TD>
    <TD>9</TD>
    <TD><CODE class=3D"literal">UINT32</CODE></TD>
    <TD>optional</TD>
    <TD>The number of Unix file descriptors that                  =
accompany=20
      the message.  If omitted, it is assumed                  that no =
Unix file=20
      descriptors accompany the                  message. The actual =
file=20
      descriptors need to be                  transferred via platform =
specific=20
      mechanism                  out-of-band. They must be sent at the =
same time=20
      as                  part of the message itself. They may not be =
sent      =20
                 before the first byte of the message itself is          =
       =20
      transferred or after the last byte of the message                  =

    itself.</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-protocol-names"></A>Valid=20
Names</H3></DIV></DIV></DIV>
<P>        The various names in D-Bus messages have some restrictions.   =
   =20
</P>
<P>        There is a <EM class=3D"firstterm">maximum name length</EM>   =
      of=20
255 which applies to bus names, interfaces, and members.        </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-protocol-names-interface"></A>Interface=20
names</H4></DIV></DIV></DIV>
<P>          Interfaces have names with type <CODE=20
class=3D"literal">STRING</CODE>, meaning that           they must be =
valid UTF-8.=20
However, there are also some           additional restrictions that =
apply to=20
interface names           specifically:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>Interface names are composed of 1 or more elements separated by     =
       =20
     a period ('.') character. All elements must contain at least        =
       =20
   one character.                 </P></LI>
  <LI class=3D"listitem">
  <P>Each element must only contain the ASCII characters                 =

  "[A-Z][a-z][0-9]_" and must not begin with a digit.                 =
</P></LI>
  <LI class=3D"listitem">
  <P>Interface names must contain at least one '.' (period)              =

  character (and thus at least two elements).               </P></LI>
  <LI class=3D"listitem">
  <P>Interface names must not begin with a '.' (period) =
character.</P></LI>
  <LI class=3D"listitem">
  <P>Interface names must not exceed the maximum name =
length.</P></LI></UL></DIV>
<P></P>
<P>          Interface names should start with the reversed DNS domain =
name of  =20
       the author of the interface (in lower-case), like interface names =
       =20
 in Java. It is conventional for the rest of the interface name          =
to=20
consist of words run together, with initial capital letters          on =
all=20
words ("CamelCase"). Several levels of hierarchy can be used.          =
It is=20
also a good idea to include the major version of the interface          =
in the=20
name, and increment it if incompatible changes are made;          this =
way, a=20
single object can implement several versions of an          interface in =

parallel, if necessary.         </P>
<P>          For instance, if the owner of <CODE=20
class=3D"literal">example.com</CODE> is          developing a D-Bus API =
for a=20
music player, they might define          interfaces called <CODE=20
class=3D"literal">com.example.MusicPlayer1</CODE>,           <CODE=20
class=3D"literal">com.example.MusicPlayer1.Track</CODE> and           =
<CODE class=3D"literal">com.example.MusicPlayer1.Seekable</CODE>.=20
        </P>
<P>          D-Bus does not distinguish between the concepts that would =
be      =20
   called classes and interfaces in Java: either can be identified on    =
     =20
D-Bus by an interface name.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-protocol-names-bus"></A>Bus=20
names</H4></DIV></DIV></DIV>
<P>          Connections have one or more bus names associated with =
them.       =20
  A connection has exactly one bus name that is a <EM =
class=3D"firstterm">unique  =20
         connection name</EM>. The unique connection name remains        =
  with=20
the connection for its entire lifetime.          A bus name is of type =
<CODE=20
class=3D"literal">STRING</CODE>,          meaning that it must be valid =
UTF-8.=20
However, there are also          some additional restrictions that apply =
to bus=20
names           specifically:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>Bus names that start with a colon (':')                character =
are unique=20
  connection names. Other bus names                are called <EM =
class=3D"firstterm">well-known=20
  bus names</EM>.                 </P></LI>
  <LI class=3D"listitem">
  <P>Bus names are composed of 1 or more elements separated by           =
     a=20
  period ('.') character. All elements must contain at least             =
    one=20
  character.                 </P></LI>
  <LI class=3D"listitem">
  <P>Each element must only contain the ASCII characters                 =

  "[A-Z][a-z][0-9]_-". Only elements that are part of a unique           =
    =20
  connection name may begin with a digit, elements in                =
other bus=20
  names must not begin with a digit.                 </P></LI>
  <LI class=3D"listitem">
  <P>Bus names must contain at least one '.' (period)              =
character=20
  (and thus at least two elements).               </P></LI>
  <LI class=3D"listitem">
  <P>Bus names must not begin with a '.' (period) character.</P></LI>
  <LI class=3D"listitem">
  <P>Bus names must not exceed the maximum name =
length.</P></LI></UL></DIV>
<P></P>
<P>          Note that the hyphen ('-') character is allowed in bus =
names but   =20
      not in interface names.         </P>
<P>          Like <A title=3D"Interface names" class=3D"link" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-interface">interface=20
           names</A>, well-known bus names should start with the         =
=20
reversed DNS domain name of the author of the interface (in         =20
lower-case), and it is conventional for the rest of the well-known       =
   bus=20
name to consist of words run together, with initial          capital =
letters. As=20
with interface names, including a version          number in well-known =
bus=20
names is a good idea; it's possible to          have the well-known bus =
name for=20
more than one version          simultaneously if backwards compatibility =
is=20
required.         </P>
<P>          If a well-known bus name implies the presence of a "main"=20
interface,          that "main" interface is often given the same name =
as       =20
  the well-known bus name, and situated at the corresponding object      =
   =20
path. For instance, if the owner of <CODE =
class=3D"literal">example.com</CODE>    =20
     is developing a D-Bus API for a music player, they might define     =
    =20
that any application that takes the well-known name           <CODE =
class=3D"literal">com.example.MusicPlayer1</CODE>=20
should have an object          at the object path <CODE=20
class=3D"literal">/com/example/MusicPlayer1</CODE>          which =
implements the=20
interface           <CODE =
class=3D"literal">com.example.MusicPlayer1</CODE>.      =20
  </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-protocol-names-member"></A>Member =

names</H4></DIV></DIV></DIV>
<P>          Member (i.e. method or signal) names:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>Must only contain the ASCII characters                =
"[A-Z][a-z][0-9]_"=20
  and may not begin with a                digit.</P></LI>
  <LI class=3D"listitem">
  <P>Must not contain the '.' (period) character.</P></LI>
  <LI class=3D"listitem">
  <P>Must not exceed the maximum name length.</P></LI>
  <LI class=3D"listitem">
  <P>Must be at least 1 byte in length.</P></LI></UL></DIV>
<P></P>
<P>          It is conventional for member names on D-Bus to consist of  =
       =20
capitalized words with no punctuation ("camel-case").          Method =
names=20
should usually be verbs, such as           <CODE=20
class=3D"literal">GetItems</CODE>, and signal names should usually be    =
      a=20
description of an event, such as <CODE =
class=3D"literal">ItemsChanged</CODE>.     =20
   </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-protocol-names-error"></A>Error=20
names</H4></DIV></DIV></DIV>
<P>          Error names have the same restrictions as interface names.  =
      =20
</P>
<P>          Error names have the same naming conventions as interface   =
      =20
names, and often contain <CODE class=3D"literal">.Error.</CODE>; for =
instance,    =20
     the owner of <CODE class=3D"literal">example.com</CODE> might =
define the     =20
    errors <CODE=20
class=3D"literal">com.example.MusicPlayer.Error.FileNotFound</CODE>      =
    and=20
<CODE =
class=3D"literal">com.example.MusicPlayer.Error.OutOfMemory</CODE>.      =
   =20
The errors defined by D-Bus itself, such as           <CODE=20
class=3D"literal">org.freedesktop.DBus.Error.Failed</CODE>, follow a     =
    =20
similar pattern.         </P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-protocol-types"></A>Message=20
Types</H3></DIV></DIV></DIV>
<P>        Each of the message types (<CODE =
class=3D"literal">METHOD_CALL</CODE>,=20
<CODE class=3D"literal">METHOD_RETURN</CODE>, <CODE =
class=3D"literal">ERROR</CODE>,=20
and         <CODE class=3D"literal">SIGNAL</CODE>) has its own expected =
usage=20
conventions and header fields.        This section describes these =
conventions. =20
     </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-protocol-types-method"></A>Method =

Calls</H4></DIV></DIV></DIV>
<P>          Some messages invoke an operation on a remote object.  =
These are   =20
      called method call messages and have the type tag <CODE=20
class=3D"literal">METHOD_CALL</CODE>. Such          messages map =
naturally to=20
methods on objects in a typical program.         </P>
<P>          A method call message is required to have a <CODE=20
class=3D"literal">MEMBER</CODE> header field          indicating the =
name of the=20
method. Optionally, the message has an           <CODE=20
class=3D"literal">INTERFACE</CODE> field giving the interface the method =
is a part=20
of.          Including the <CODE class=3D"literal">INTERFACE</CODE> in =
all method=20
call          messages is strongly recommended.         </P>
<P>          In the absence of an <CODE =
class=3D"literal">INTERFACE</CODE> field,=20
if two          or more interfaces on the same object have a method with =
the=20
same          name, it is undefined which of those methods will be =
invoked.     =20
    Implementations may choose to either return an error, or deliver the =
       =20
 message as though it had an arbitrary one of those interfaces.         =
</P>
<P>          In some situations (such as the well-known system bus), =
messages   =20
      are filtered through an access-control list external to the        =
 =20
remote object implementation. If that filter rejects certain          =
messages=20
by matching their interface, or accepts only messages          to =
specific=20
interfaces, it must also reject messages that have no           <CODE =
class=3D"literal">INTERFACE</CODE>:=20
otherwise, malicious          applications could use this to bypass the =
filter. =20
       </P>
<P>          Method call messages also include a <CODE=20
class=3D"literal">PATH</CODE> field          indicating the object to =
invoke the=20
method on. If the call is passing          through a message bus, the =
message=20
will also have a           <CODE class=3D"literal">DESTINATION</CODE> =
field giving=20
the name of the connection          to receive the message.         </P>
<P>          When an application handles a method call message, it is =
required=20
to          return a reply. The reply is identified by a <CODE=20
class=3D"literal">REPLY_SERIAL</CODE> header field          indicating =
the serial=20
number of the <CODE class=3D"literal">METHOD_CALL</CODE> being replied =
to. The    =20
     reply can have one of two types; either <CODE=20
class=3D"literal">METHOD_RETURN</CODE> or <CODE =
class=3D"literal">ERROR</CODE>.     =20
   </P>
<P>          If the reply has type <CODE =
class=3D"literal">METHOD_RETURN</CODE>,=20
the arguments to the reply message           are the return value(s) or =
"out=20
parameters" of the method call.           If the reply has type <CODE =
class=3D"literal">ERROR</CODE>,=20
then an "exception" has been thrown,           and the call fails; no =
return=20
value will be provided. It makes           no sense to send multiple =
replies to=20
the same method call.         </P>
<P>          Even if a method call has no return values, a <CODE=20
class=3D"literal">METHOD_RETURN</CODE>           reply is required, so =
the caller=20
will know the method           was successfully processed.         </P>
<P>          The <CODE class=3D"literal">METHOD_RETURN</CODE> or <CODE =
class=3D"literal">ERROR</CODE>=20
reply message must have the <CODE class=3D"literal">REPLY_SERIAL</CODE>  =
        =20
header field.         </P>
<P>          If a <CODE class=3D"literal">METHOD_CALL</CODE> message has =
the flag=20
<CODE class=3D"literal">NO_REPLY_EXPECTED</CODE>,           then as an=20
optimization the application receiving the method           call may =
choose to=20
omit the reply message (regardless of           whether the reply would =
have=20
been <CODE class=3D"literal">METHOD_RETURN</CODE> or <CODE=20
class=3D"literal">ERROR</CODE>).           However, it is also =
acceptable to=20
ignore the <CODE class=3D"literal">NO_REPLY_EXPECTED</CODE>          =
flag and=20
reply anyway.         </P>
<P>          Unless a message has the flag <CODE=20
class=3D"literal">NO_AUTO_START</CODE>, if the          destination name =
does not=20
exist then a program to own the destination          name will be =
started before=20
the message is delivered.  The message          will be held until the =
new=20
program is successfully started or has          failed to start; in case =
of=20
failure, an error will be returned. This          flag is only relevant =
in the=20
context of a message bus, it is ignored          during one-to-one =
communication=20
with no intermediate bus.         </P>
<DIV class=3D"sect4">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H5 class=3D"title"><A =
name=3D"message-protocol-types-method-apis"></A>Mapping=20
method calls to native APIs</H5></DIV></DIV></DIV>
<P>            APIs for D-Bus may map method calls to a method call in a =

specific            programming language, such as C++, or may map a =
method call=20
written            in an IDL to a D-Bus message.           </P>
<P>            In APIs of this nature, arguments to a method are often =
termed=20
"in"            (which implies sent in the <CODE=20
class=3D"literal">METHOD_CALL</CODE>), or "out" (which implies           =
 returned=20
in the <CODE class=3D"literal">METHOD_RETURN</CODE>). Some APIs such as =
CORBA also=20
have            "inout" arguments, which are both sent and received, =
i.e. the=20
caller            passes in a value which is modified. Mapped to D-Bus, =
an=20
"inout"            argument is equivalent to an "in" argument, followed =
by an=20
"out"            argument. You can't pass things "by reference" over the =
wire,=20
so            "inout" is purely an illusion of the in-process API.       =
   =20
</P>
<P>            Given a method with zero or one return values, followed =
by zero=20
or more            arguments, where each argument may be "in", "out", or =

"inout", the            caller constructs a message by appending each =
"in" or=20
"inout" argument,            in order. "out" arguments are not =
represented in=20
the caller's message.           </P>
<P>            The recipient constructs a reply by appending first the =
return=20
value             if any, then each "out" or "inout" argument, in order. =
       =20
    "in" arguments are not represented in the reply message.           =
</P>
<P>            Error replies are normally mapped to exceptions in =
languages that=20
have            exceptions.           </P>
<P>            In converting from native APIs to D-Bus, it is perhaps =
nice to   =20
         map D-Bus naming conventions ("FooBar") to native conventions   =
       =20
  such as "fooBar" or "foo_bar" automatically. This is OK             as =
long as=20
you can say that the native API is one that             was specifically =
written=20
for D-Bus. It makes the most sense            when writing object=20
implementations that will be exported             over the bus. Object =
proxies=20
used to invoke remote D-Bus             objects probably need the =
ability to=20
call any D-Bus method,            and thus a magic name mapping like =
this could=20
be a problem.           </P>
<P>            This specification doesn't require anything of native API =

bindings;            the preceding is only a suggested convention for=20
consistency             among bindings.           </P></DIV></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-protocol-types-signal"></A>Signal =

Emission</H4></DIV></DIV></DIV>
<P>          Unlike method calls, signal emissions have no replies.      =
     A=20
signal emission is simply a single message of type <CODE=20
class=3D"literal">SIGNAL</CODE>.          It must have three header =
fields: <CODE=20
class=3D"literal">PATH</CODE> giving the object           the signal was =
emitted=20
from, plus <CODE class=3D"literal">INTERFACE</CODE> and <CODE=20
class=3D"literal">MEMBER</CODE> giving          the fully-qualified name =
of the=20
signal. The <CODE class=3D"literal">INTERFACE</CODE> header is required  =
       =20
for signals, though it is optional for method calls.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A=20
name=3D"message-protocol-types-errors"></A>Errors</H4></DIV></DIV></DIV>
<P>          Messages of type <CODE class=3D"literal">ERROR</CODE> are =
most=20
commonly replies           to a <CODE =
class=3D"literal">METHOD_CALL</CODE>, but=20
may be returned in reply           to any kind of message. The message =
bus for=20
example          will return an <CODE class=3D"literal">ERROR</CODE> in =
reply to a=20
signal emission if           the bus does not have enough memory to send =
the=20
signal.         </P>
<P>          An <CODE class=3D"literal">ERROR</CODE> may have any =
arguments, but=20
if the first           argument is a <CODE =
class=3D"literal">STRING</CODE>, it=20
must be an error message.          The error message may be logged or =
shown to=20
the user          in some way.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-protocol-types-notation"></A>Notation in this=20
document</H4></DIV></DIV></DIV>
<P>          This document uses a simple pseudo-IDL to describe =
particular=20
method           calls and signals. Here is an example of a method call: =
       =20
  </P>
<PRE class=3D"programlisting">            =
org.freedesktop.DBus.StartServiceByName (in STRING name, in UINT32 flags,=0A=
                                                     out UINT32 =
resultcode)=0A=
          </PRE>
<P>          This means <CODE class=3D"literal">INTERFACE</CODE> =3D=20
org.freedesktop.DBus, <CODE class=3D"literal">MEMBER</CODE> =3D =
StartServiceByName, =20
          <CODE class=3D"literal">METHOD_CALL</CODE> arguments are <CODE =
class=3D"literal">STRING</CODE>=20
and <CODE class=3D"literal">UINT32</CODE>, <CODE=20
class=3D"literal">METHOD_RETURN</CODE> argument          is <CODE=20
class=3D"literal">UINT32</CODE>. Remember that the <CODE=20
class=3D"literal">MEMBER</CODE> field can't contain any '.' (period)     =
    =20
characters so it's known that the last part of the name in          the =
"IDL" is=20
the member name.         </P>
<P>          In C++ that might end up looking like this:           </P>
<PRE class=3D"programlisting">            unsigned int =
org::freedesktop::DBus::StartServiceByName (const char  *name,=0A=
                                                                     =
unsigned int flags);=0A=
          </PRE>
<P>          or equally valid, the return value could be done as an =
argument:   =20
       </P>
<PRE class=3D"programlisting">            void =
org::freedesktop::DBus::StartServiceByName (const char   *name, =0A=
                                                             unsigned =
int  flags,=0A=
                                                             unsigned =
int *resultcode);=0A=
          </PRE>
<P>          It's really up to the API designer how they want to make    =
      =20
this look. You could design an API where the namespace wasn't used       =
    in=20
C++, using STL or Qt, using varargs, or whatever you wanted.         =
</P>
<P>          Signals are written as follows:           </P>
<PRE class=3D"programlisting">            org.freedesktop.DBus.NameLost =
(STRING name)=0A=
          </PRE>
<P>          Signals don't specify "in" vs. "out" because only           =
a=20
single direction is possible.         </P>
<P>          It isn't especially encouraged to use this lame pseudo-IDL =
in=20
actual          API implementations; you might use the native notation =
for the  =20
       language you're using, or you might use COM or CORBA IDL, for =
example.   =20
     </P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"message-protocol-handling-invalid"></A>Invalid=20
Protocol and Spec Extensions</H3></DIV></DIV></DIV>
<P>        For security reasons, the D-Bus protocol should be strictly =
parsed=20
and        validated, with the exception of defined extension points. =
Any=20
invalid        protocol or spec violations should result in immediately =
dropping=20
the        connection without notice to the other end. Exceptions should =
be     =20
  carefully considered, e.g. an exception may be warranted for a       =20
well-understood idiosyncrasy of a widely-deployed implementation.  In    =
   =20
cases where the other end of a connection is 100% trusted and known to   =
     be=20
friendly, skipping validation for performance reasons could also make    =
   =20
sense in certain cases.       </P>
<P>        Generally speaking violations of the "must" requirements in =
this spec=20
        should be considered possible attempts to exploit security, and=20
violations         of the "should" suggestions should be considered =
legitimate=20
(though perhaps        they should generate an error in some cases).     =
  </P>
<P>        The following extension points are built in to D-Bus on =
purpose and=20
must        not be treated as invalid protocol. The extension points are =

intended        for use by future versions of this spec, they are not =
intended=20
for third        parties.  At the moment, the only way a third party =
could=20
extend D-Bus        without breaking interoperability would be to =
introduce a=20
way to negotiate new        feature support as part of the auth =
protocol, using=20
EXTENSION_-prefixed        commands. There is not yet a standard way to=20
negotiate features.         </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>              In the authentication protocol (see <A =
title=3D"Authentication Protocol"=20
  class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#auth-prot=
ocol">the=20
  section called =93Authentication Protocol=94</A>) unknown              =
   commands=20
  result in an ERROR rather than a disconnect. This enables              =
  =20
  future extensions to the protocol. Commands starting with EXTENSION_ =
are      =20
            reserved for third parties.             </P></LI>
  <LI class=3D"listitem">
  <P>              The authentication protocol supports pluggable auth=20
  mechanisms.             </P></LI>
  <LI class=3D"listitem">
  <P>              The address format (see <A title=3D"Server Addresses" =
class=3D"xref"=20
  =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#addresses=
">the=20
  section called =93Server Addresses=94</A>) supports new              =
kinds of=20
  transport.             </P></LI>
  <LI class=3D"listitem">
  <P>              Messages with an unknown type (something other than   =
       =20
      <CODE class=3D"literal">METHOD_CALL</CODE>, <CODE=20
  class=3D"literal">METHOD_RETURN</CODE>,               <CODE=20
  class=3D"literal">ERROR</CODE>, <CODE class=3D"literal">SIGNAL</CODE>) =
are=20
  ignored.               Unknown-type messages must still be well-formed =
in the=20
  same way               as the known messages, however. They still have =
the=20
  normal               header and body.             </P></LI>
  <LI class=3D"listitem">
  <P>              Header fields with an unknown or unexpected field =
code must=20
  be ignored,               though again they must still be well-formed. =
       =20
      </P></LI>
  <LI class=3D"listitem">
  <P>              New standard interfaces (with new methods and =
signals) can of=20
  course be added.             </P></LI></UL></DIV>
<P></P></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"auth-protocol"></A>Authentication =
Protocol</H2></DIV></DIV></DIV>
<P>      Before the flow of messages begins, two applications must     =20
authenticate. A simple plain-text protocol is used for      =
authentication; this=20
protocol is a SASL profile, and maps fairly      directly from the SASL=20
specification. The message encoding is      NOT used here, only plain =
text=20
messages.     </P>
<P>      In examples, "C:" and "S:" indicate lines sent by the client =
and     =20
server respectively.     </P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-protocol-overview"></A>Protocol=20
Overview</H3></DIV></DIV></DIV>
<P>        The protocol is a line-based protocol, where each line ends =
with     =20
  \r\n. Each line begins with an all-caps ASCII command name containing  =
     =20
only the character range [A-Z_], a space, then any arguments for the     =
  =20
command, then the \r\n ending the line. The protocol is        =
case-sensitive.=20
All bytes must be in the ASCII character set.        Commands from the =
client to=20
the server are as follows:         </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>AUTH [mechanism] [initial-response]</P></LI>
  <LI class=3D"listitem">
  <P>CANCEL</P></LI>
  <LI class=3D"listitem">
  <P>BEGIN</P></LI>
  <LI class=3D"listitem">
  <P>DATA &lt;data in hex encoding&gt;</P></LI>
  <LI class=3D"listitem">
  <P>ERROR [human-readable error explanation]</P></LI>
  <LI class=3D"listitem">
  <P>NEGOTIATE_UNIX_FD</P></LI></UL></DIV>
<P>        From server to client are as follows:         </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>REJECTED &lt;space-separated list of mechanism names&gt;</P></LI>
  <LI class=3D"listitem">
  <P>OK &lt;GUID in hex&gt;</P></LI>
  <LI class=3D"listitem">
  <P>DATA &lt;data in hex encoding&gt;</P></LI>
  <LI class=3D"listitem">
  <P>ERROR</P></LI>
  <LI class=3D"listitem">
  <P>AGREE_UNIX_FD</P></LI></UL></DIV>
<P></P>
<P>        Unofficial extensions to the command set must begin with the =
letters =20
       "EXTENSION_", to avoid conflicts with future official commands.   =
    =20
For example, "EXTENSION_COM_MYDOMAIN_DO_STUFF".       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-nul-byte"></A>Special =
credentials-passing nul=20
byte</H3></DIV></DIV></DIV>
<P>        Immediately after connecting to the server, the client must =
send a   =20
    single nul byte. This byte may be accompanied by credentials       =20
information on some operating systems that use sendmsg() with        =
SCM_CREDS=20
or SCM_CREDENTIALS to pass credentials over UNIX domain        sockets. =
However,=20
the nul byte must be sent even on other kinds of        socket, and even =
on=20
operating systems that do not require a byte to be        sent in order =
to=20
transmit credentials. The text protocol described in        this =
document begins=20
after the single nul byte. If the first byte        received from the =
client is=20
not a nul byte, the server may disconnect         that client.       =
</P>
<P>        A nul byte in any context other than the initial byte is an =
error;   =20
     the protocol is ASCII-only.       </P>
<P>        The credentials sent along with the nul byte may be used with =
the    =20
    SASL mechanism EXTERNAL.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-auth"></A>AUTH=20
command</H3></DIV></DIV></DIV>
<P>        If an AUTH command has no arguments, it is a request to list  =
     =20
available mechanisms. The server must respond with a REJECTED        =
command=20
listing the mechanisms it understands, or with an error.       </P>
<P>        If an AUTH command specifies a mechanism, and the server =
supports    =20
   said mechanism, the server should begin exchanging SASL       =20
challenge-response data with the client using DATA commands.       </P>
<P>        If the server does not support the mechanism given in the =
AUTH       =20
command, it must send either a REJECTED command listing the mechanisms   =
     it=20
does support, or an error.       </P>
<P>        If the [initial-response] argument is provided, it is =
intended for=20
use        with mechanisms that have no initial challenge (or an empty =
initial  =20
     challenge), as if it were the argument to an initial DATA command. =
If      =20
 the selected mechanism has an initial challenge and [initial-response]  =
     =20
was provided, the server should reject authentication by sending       =20
REJECTED.       </P>
<P>        If authentication succeeds after exchanging DATA commands,    =
     an=20
OK command must be sent to the client.       </P>
<P>        The first octet received by the server after the \r\n of the =
BEGIN   =20
    command from the client must be the first octet of the       =20
authenticated/encrypted stream of D-Bus messages.       </P>
<P>        If BEGIN is received by the server, the first octet received  =
     =20
by the client after the \r\n of the OK command must be the        first =
octet of=20
the authenticated/encrypted stream of D-Bus        messages.       =
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-cancel"></A>CANCEL=20
Command</H3></DIV></DIV></DIV>
<P>        At any time up to sending the BEGIN command, the client may =
send a   =20
    CANCEL command. On receiving the CANCEL command, the server must     =
   send=20
a REJECTED command and abort the current authentication        exchange. =
     =20
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-data"></A>DATA=20
Command</H3></DIV></DIV></DIV>
<P>        The DATA command may come from either client or server, and =
simply   =20
     contains a hex-encoded block of data to be interpreted         =
according to=20
the SASL mechanism in use.       </P>
<P>        Some SASL mechanisms support sending an "empty string";       =
  FIXME=20
we need some way to do this.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-begin"></A>BEGIN=20
Command</H3></DIV></DIV></DIV>
<P>        The BEGIN command acknowledges that the client has received =
an       =20
 OK command from the server, and that the stream of messages        is =
about to=20
begin.        </P>
<P>        The first octet received by the server after the \r\n of the =
BEGIN   =20
    command from the client must be the first octet of the       =20
authenticated/encrypted stream of D-Bus messages.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-rejected"></A>REJECTED=20
Command</H3></DIV></DIV></DIV>
<P>        The REJECTED command indicates that the current =
authentication       =20
exchange has failed, and further exchange of DATA is inappropriate.      =
  The=20
client would normally try another mechanism, or try providing        =
different=20
responses to challenges.       </P>
<P>        Optionally, the REJECTED command has a space-separated list =
of       =20
available auth mechanisms as arguments. If a server ever provides        =
a list=20
of supported mechanisms, it must provide the same list         each time =
it=20
sends a REJECTED message. Clients are free to         ignore all lists =
received=20
after the first.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-ok"></A>OK=20
Command</H3></DIV></DIV></DIV>
<P>        The OK command indicates that the client has been       =20
authenticated. The client may now proceed with negotiating        Unix =
file=20
descriptor passing. To do that it shall send        NEGOTIATE_UNIX_FD to =
the=20
server.       </P>
<P>        Otherwise, the client must respond to the OK command by       =
=20
sending a BEGIN command, followed by its stream of messages,        or =
by=20
disconnecting.  The server must not accept additional        commands =
using this=20
protocol after the BEGIN command has been        received. Further =
communication=20
will be a stream of D-Bus        messages (optionally encrypted, as =
negotiated)=20
rather than        this protocol.       </P>
<P>        If a client sends BEGIN the first octet received by the =
client       =20
after the \r\n of the OK command must be the first octet of        the=20
authenticated/encrypted stream of D-Bus messages.       </P>
<P>        The OK command has one argument, which is the GUID of the =
server.    =20
   See <A title=3D"Server Addresses" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#addresses=
">the=20
section called =93Server Addresses=94</A> for more on server GUIDs.      =
 </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-error"></A>ERROR=20
Command</H3></DIV></DIV></DIV>
<P>        The ERROR command indicates that either server or client did =
not     =20
  know a command, does not accept the given command in the current       =
=20
context, or did not understand the arguments to the command. This        =
allows=20
the protocol to be extended; a client or server can send a        =
command=20
present or permitted only in new protocol versions, and if        an =
ERROR is=20
received instead of an appropriate response, fall back        to using =
some=20
other technique.       </P>
<P>        If an ERROR is sent, the server or client that sent the       =
 error=20
must continue as if the command causing the ERROR had never been       =20
received. However, the the server or client receiving the error         =
should=20
try something other than whatever caused the error;         if only=20
canceling/rejecting the authentication.       </P>
<P>        If the D-Bus protocol changes incompatibly at some future =
time,      =20
 applications implementing the new protocol would probably be able to    =
   =20
check for support of the new protocol by sending a new command and       =
=20
receiving an ERROR from applications that don't understand it. Thus the  =
     =20
ERROR feature of the auth protocol is an escape hatch that lets us       =
=20
negotiate extensions or changes to the D-Bus protocol in the future.     =
 =20
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"auth-command-negotiate-unix-fd"></A>NEGOTIATE_UNIX_FD=20
Command</H3></DIV></DIV></DIV>
<P>        The NEGOTIATE_UNIX_FD command indicates that the client       =
=20
supports Unix file descriptor passing. This command may only        be =
sent=20
after the connection is authenticated, i.e. after OK        was received =
by the=20
client. This command may only be sent on        transports that support =
Unix=20
file descriptor passing.       </P>
<P>        On receiving NEGOTIATE_UNIX_FD the server must respond with   =
    =20
either AGREE_UNIX_FD or ERROR. It shall respond the former if        the =

transport chosen supports Unix file descriptor passing and        the =
server=20
supports this feature. It shall respond the latter        if the =
transport does=20
not support Unix file descriptor        passing, the server does not =
support=20
this feature, or the        server decides not to enable file descriptor =
passing=20
due to        security or other reasons.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"auth-command-agree-unix-fd"></A>AGREE_UNIX_FD=20
Command</H3></DIV></DIV></DIV>
<P>        The AGREE_UNIX_FD command indicates that the server supports  =
     =20
Unix file descriptor passing. This command may only be sent        after =
the=20
connection is authenticated, and the client sent        =
NEGOTIATE_UNIX_FD to=20
enable Unix file descriptor passing. This        command may only be =
sent on=20
transports that support Unix file        descriptor passing.       </P>
<P>        On receiving AGREE_UNIX_FD the client must respond with =
BEGIN,       =20
followed by its stream of messages, or by disconnecting.  The        =
server must=20
not accept additional commands using this protocol        after the =
BEGIN=20
command has been received. Further        communication will be a stream =
of=20
D-Bus messages (optionally        encrypted, as negotiated) rather than =
this=20
protocol.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-command-future"></A>Future=20
Extensions</H3></DIV></DIV></DIV>
<P>        Future extensions to the authentication and negotiation       =
=20
protocol are possible. For that new commands may be        introduced. =
If a=20
client or server receives an unknown command        it shall respond =
with ERROR=20
and not consider this fatal. New        commands may be introduced both =
before,=20
and after        authentication, i.e. both before and after the OK =
command.     =20
 </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-examples"></A>Authentication=20
examples</H3></DIV></DIV></DIV>
<P></P>
<DIV class=3D"figure"><A name=3D"idp56006864"></A>
<P class=3D"title"><B>Figure&nbsp;1.&nbsp;Example of successful magic =
cookie=20
authentication</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            (MAGIC_COOKIE is a made up =
mechanism)=0A=
=0A=
            C: AUTH MAGIC_COOKIE 3138363935333137393635383634=0A=
            S: OK 1234deadbeef=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56008688"></A>
<P class=3D"title"><B>Figure&nbsp;2.&nbsp;Example of finding out =
mechanisms then=20
picking one</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            C: AUTH=0A=
            S: REJECTED KERBEROS_V4 SKEY=0A=
            C: AUTH SKEY 7ab83f32ee=0A=
            S: DATA 8799cabb2ea93e=0A=
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f=0A=
            S: OK 1234deadbeef=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56010592"></A>
<P class=3D"title"><B>Figure&nbsp;3.&nbsp;Example of client sends =
unknown command=20
then falls back to regular auth</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            C: FOOBAR=0A=
            S: ERROR=0A=
            C: AUTH MAGIC_COOKIE 3736343435313230333039=0A=
            S: OK 1234deadbeef=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56012480"></A>
<P class=3D"title"><B>Figure&nbsp;4.&nbsp;Example of server doesn't =
support=20
initial auth mechanism</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            C: AUTH MAGIC_COOKIE =
3736343435313230333039=0A=
            S: REJECTED KERBEROS_V4 SKEY=0A=
            C: AUTH SKEY 7ab83f32ee=0A=
            S: DATA 8799cabb2ea93e=0A=
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f=0A=
            S: OK 1234deadbeef=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56014496"></A>
<P class=3D"title"><B>Figure&nbsp;5.&nbsp;Example of wrong password or =
the like=20
followed by successful retry</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            C: AUTH MAGIC_COOKIE =
3736343435313230333039=0A=
            S: REJECTED KERBEROS_V4 SKEY=0A=
            C: AUTH SKEY 7ab83f32ee=0A=
            S: DATA 8799cabb2ea93e=0A=
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f=0A=
            S: REJECTED=0A=
            C: AUTH SKEY 7ab83f32ee=0A=
            S: DATA 8799cabb2ea93e=0A=
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f=0A=
            S: OK 1234deadbeef=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56016672"></A>
<P class=3D"title"><B>Figure&nbsp;6.&nbsp;Example of skey cancelled and=20
restarted</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            C: AUTH MAGIC_COOKIE =
3736343435313230333039=0A=
            S: REJECTED KERBEROS_V4 SKEY=0A=
            C: AUTH SKEY 7ab83f32ee=0A=
            S: DATA 8799cabb2ea93e=0A=
            C: CANCEL=0A=
            S: REJECTED=0A=
            C: AUTH SKEY 7ab83f32ee=0A=
            S: DATA 8799cabb2ea93e=0A=
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f=0A=
            S: OK 1234deadbeef=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56018736"></A>
<P class=3D"title"><B>Figure&nbsp;7.&nbsp;Example of successful magic =
cookie=20
authentication with successful negotiation of Unix FD passing</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            (MAGIC_COOKIE is a made up =
mechanism)=0A=
=0A=
            C: AUTH MAGIC_COOKIE 3138363935333137393635383634=0A=
            S: OK 1234deadbeef=0A=
            C: NEGOTIATE_UNIX_FD=0A=
            S: AGREE_UNIX_FD=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<DIV class=3D"figure"><A name=3D"idp56020736"></A>
<P class=3D"title"><B>Figure&nbsp;8.&nbsp;Example of successful magic =
cookie=20
authentication with unsuccessful negotiation of Unix FD passing</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            (MAGIC_COOKIE is a made up =
mechanism)=0A=
=0A=
            C: AUTH MAGIC_COOKIE 3138363935333137393635383634=0A=
            S: OK 1234deadbeef=0A=
            C: NEGOTIATE_UNIX_FD=0A=
            S: ERROR=0A=
            C: BEGIN=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-states"></A>Authentication state=20
diagrams</H3></DIV></DIV></DIV>
<P>        This section documents the auth protocol in terms of         =
a state=20
machine for the client and the server. This is         probably the most =
robust=20
way to implement the protocol.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"auth-states-client"></A>Client=20
states</H4></DIV></DIV></DIV>
<P>          To more precisely describe the interaction between the      =
   =20
protocol state machine and the authentication mechanisms the          =
following=20
notation is used: MECH(CHALL) means that the          server challenge =
CHALL was=20
fed to the mechanism MECH, which          returns one of           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                CONTINUE(RESP) means continue the auth conversation =
       =20
         and send RESP as the response to the server;               =
</P></LI>
  <LI class=3D"listitem">
  <P>                OK(RESP) means that after sending RESP to the =
server       =20
          the client side of the auth conversation is finished           =
    =20
  and the server should return "OK";               </P></LI>
  <LI class=3D"listitem">
  <P>                ERROR means that CHALL was invalid and could not be =
       =20
         processed.               </P></LI></UL></DIV>
<P>                    Both RESP and CHALL may be empty.         </P>
<P>          The Client starts by getting an initial response from the   =
      =20
default mechanism and sends AUTH MECH RESP, or AUTH MECH if          the =

mechanism did not provide an initial response.  If the          =
mechanism=20
returns CONTINUE, the client starts in state           <SPAN=20
class=3D"emphasis"><EM>WaitingForData</EM></SPAN>, if the mechanism      =
   =20
returns OK the client starts in state           <SPAN=20
class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>.         </P>
<P>          The client should keep track of available mechanisms and    =
     =20
which it mechanisms it has already attempted. This list is          used =
to=20
decide which AUTH command to send. When the list is          exhausted, =
the=20
client should give up and close the          connection.         </P>
<P><B><SPAN class=3D"emphasis"><EM>WaitingForData</EM></SPAN>.&nbsp;</B> =
         =20
  </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                  Receive DATA CHALL                   </P>
  <TABLE class=3D"simplelist" border=3D"0" summary=3D"Simple list">
    <TBODY>
    <TR>
      <TD>                      MECH(CHALL) returns CONTINUE(RESP) =
&#8594; send     =20
                        DATA RESP, goto                       <SPAN =
class=3D"emphasis"><EM>WaitingForData</EM></SPAN>=20
                            </TD></TR>
    <TR>
      <TD>                      MECH(CHALL) returns OK(RESP) &#8594; =
send DATA      =20
                       RESP, goto <SPAN=20
        class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>                  =
   </TD></TR>
    <TR>
      <TD>                      MECH(CHALL) returns ERROR &#8594; send =
ERROR        =20
                     [msg], goto <SPAN=20
        class=3D"emphasis"><EM>WaitingForData</EM></SPAN>                =
    =20
    </TD></TR></TBODY></TABLE>
  <P></P></LI>
  <LI class=3D"listitem">
  <P>                  Receive REJECTED [mechs] &#8594;                  =
send AUTH=20
  [next mech], goto                  WaitingForData or <SPAN=20
  class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>                 =
</P></LI>
  <LI class=3D"listitem">
  <P>                  Receive ERROR &#8594; send                  =
CANCEL, goto       =20
             <SPAN class=3D"emphasis"><EM>WaitingForReject</EM></SPAN>   =
         =20
      </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive OK &#8594; send                  BEGIN, =
terminate auth =20
                  conversation, authenticated                 </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive anything else &#8594; send                =
  ERROR, goto=20
                    <SPAN =
class=3D"emphasis"><EM>WaitingForData</EM></SPAN>       =20
           </P></LI></UL></DIV>
<P></P>
<P><B><SPAN class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>.&nbsp;</B>   =
         =20
</P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                  Receive OK &#8594; send BEGIN, terminate auth     =
            =20
  conversation, <SPAN class=3D"emphasis"><EM>authenticated</EM></SPAN>   =
         =20
      </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive REJECTED [mechs] &#8594; send AUTH [next =
mech],        =20
           goto <SPAN class=3D"emphasis"><EM>WaitingForData</EM></SPAN> =
or        =20
            <SPAN class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>        =
        =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive DATA &#8594; send CANCEL, goto            =
       <SPAN=20
  class=3D"emphasis"><EM>WaitingForReject</EM></SPAN>                 =
</P></LI>
  <LI class=3D"listitem">
  <P>                  Receive ERROR &#8594; send CANCEL, goto           =
        <SPAN=20
  class=3D"emphasis"><EM>WaitingForReject</EM></SPAN>                 =
</P></LI>
  <LI class=3D"listitem">
  <P>                  Receive anything else &#8594; send ERROR, goto    =
             =20
   <SPAN class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>                 =

</P></LI></UL></DIV>
<P></P>
<P><B><SPAN =
class=3D"emphasis"><EM>WaitingForReject</EM></SPAN>.&nbsp;</B>        =20
    </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                  Receive REJECTED [mechs] &#8594; send AUTH [next =
mech],        =20
           goto <SPAN class=3D"emphasis"><EM>WaitingForData</EM></SPAN> =
or        =20
            <SPAN class=3D"emphasis"><EM>WaitingForOK</EM></SPAN>        =
        =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive anything else &#8594; terminate auth      =
           =20
  conversation, disconnect                 </P></LI></UL></DIV>
<P></P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"auth-states-server"></A>Server=20
states</H4></DIV></DIV></DIV>
<P>          For the server MECH(RESP) means that the client response    =
     =20
RESP was fed to the the mechanism MECH, which returns one of           =
</P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                CONTINUE(CHALL) means continue the auth =
conversation and   =20
              send CHALL as the challenge to the client;               =
</P></LI>
  <LI class=3D"listitem">
  <P>                OK means that the client has been successfully      =
       =20
    authenticated;               </P></LI>
  <LI class=3D"listitem">
  <P>                REJECTED means that the client failed to =
authenticate or   =20
              there was an error in RESP.               =
</P></LI></UL></DIV>
<P>          The server starts out in state           <SPAN=20
class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>.  If the client is     =
    =20
rejected too many times the server must disconnect the          client.  =
      =20
</P>
<P><B><SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>.&nbsp;</B> =
         =20
  </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                  Receive AUTH &#8594; send REJECTED [mechs], goto  =
             =20
     <SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>             =
   =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive AUTH MECH RESP                   </P>
  <TABLE class=3D"simplelist" border=3D"0" summary=3D"Simple list">
    <TBODY>
    <TR>
      <TD>                      MECH not valid mechanism &#8594; send =
REJECTED      =20
                       [mechs], goto                       <SPAN =
class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>=20
                            </TD></TR>
    <TR>
      <TD>                      MECH(RESP) returns CONTINUE(CHALL) =
&#8594; send     =20
                        DATA CHALL, goto                       <SPAN =
class=3D"emphasis"><EM>WaitingForData</EM></SPAN>=20
                            </TD></TR>
    <TR>
      <TD>                      MECH(RESP) returns OK &#8594; send OK, =
goto         =20
                     <SPAN =
class=3D"emphasis"><EM>WaitingForBegin</EM></SPAN>     =20
                       </TD></TR>
    <TR>
      <TD>                      MECH(RESP) returns REJECTED &#8594; send =
REJECTED   =20
                          [mechs], goto                       <SPAN =
class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>=20
                            </TD></TR></TBODY></TABLE>
  <P></P></LI>
  <LI class=3D"listitem">
  <P>                  Receive BEGIN &#8594; terminate                  =
auth=20
  conversation, disconnect                 </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive ERROR &#8594; send REJECTED [mechs], goto =
             =20
      <SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>            =
    =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive anything else &#8594; send                =
  ERROR, goto=20
                    <SPAN =
class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>       =20
           </P></LI></UL></DIV>
<P></P>
<P><B><SPAN class=3D"emphasis"><EM>WaitingForData</EM></SPAN>.&nbsp;</B> =
         =20
  </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                  Receive DATA RESP                   </P>
  <TABLE class=3D"simplelist" border=3D"0" summary=3D"Simple list">
    <TBODY>
    <TR>
      <TD>                      MECH(RESP) returns CONTINUE(CHALL) =
&#8594; send     =20
                        DATA CHALL, goto                       <SPAN =
class=3D"emphasis"><EM>WaitingForData</EM></SPAN>=20
                            </TD></TR>
    <TR>
      <TD>                      MECH(RESP) returns OK &#8594; send OK, =
goto         =20
                     <SPAN =
class=3D"emphasis"><EM>WaitingForBegin</EM></SPAN>     =20
                       </TD></TR>
    <TR>
      <TD>                      MECH(RESP) returns REJECTED &#8594; send =
REJECTED   =20
                          [mechs], goto                       <SPAN =
class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>=20
                            </TD></TR></TBODY></TABLE>
  <P></P></LI>
  <LI class=3D"listitem">
  <P>                  Receive BEGIN &#8594; terminate auth =
conversation,             =20
      disconnect                 </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive CANCEL &#8594; send REJECTED [mechs], =
goto             =20
       <SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>           =
     =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive ERROR &#8594; send REJECTED [mechs], goto =
             =20
      <SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>            =
    =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive anything else &#8594; send ERROR, goto    =
             =20
   <SPAN class=3D"emphasis"><EM>WaitingForData</EM></SPAN>               =
 =20
  </P></LI></UL></DIV>
<P></P>
<P><B><SPAN =
class=3D"emphasis"><EM>WaitingForBegin</EM></SPAN>.&nbsp;</B>         =20
   </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                  Receive BEGIN &#8594; terminate auth =
conversation,             =20
      client authenticated                 </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive CANCEL &#8594; send REJECTED [mechs], =
goto             =20
       <SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>           =
     =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive ERROR &#8594; send REJECTED [mechs], goto =
             =20
      <SPAN class=3D"emphasis"><EM>WaitingForAuth</EM></SPAN>            =
    =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                  Receive anything else &#8594; send ERROR, goto    =
             =20
   <SPAN class=3D"emphasis"><EM>WaitingForBegin</EM></SPAN>              =
  =20
  </P></LI></UL></DIV>
<P></P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"auth-mechanisms"></A>Authentication=20
mechanisms</H3></DIV></DIV></DIV>
<P>        This section describes some new authentication mechanisms.    =
   =20
D-Bus also allows any standard SASL mechanism of course.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A=20
name=3D"auth-mechanisms-sha"></A>DBUS_COOKIE_SHA1</H4></DIV></DIV></DIV>
<P>          The DBUS_COOKIE_SHA1 mechanism is designed to establish =
that a=20
client          has the ability to read a private file owned by the user =
being  =20
       authenticated. If the client can prove that it has access to a =
secret    =20
     cookie stored in this file, then the client is authenticated.       =
   =20
Thus the security of DBUS_COOKIE_SHA1 depends on a secure home           =

directory.         </P>
<P>          Throughout this description, "hex encoding" must output the =
digits =20
        from a to f in lower-case; the digits A to F must not be used    =
     =20
in the DBUS_COOKIE_SHA1 mechanism.         </P>
<P>          Authentication proceeds as follows:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                The client sends the username it would like to =
authenticate=20
                  as, hex-encoded.               </P></LI>
  <LI class=3D"listitem">
  <P>                The server sends the name of its "cookie context" =
(see=20
  below); a                space character; the integer ID of the secret =
cookie=20
  the client                must demonstrate knowledge of; a space =
character;=20
  then a                randomly-generated challenge string, all of this =

  hex-encoded into                one, single string.               =
</P></LI>
  <LI class=3D"listitem">
  <P>                The client locates the cookie and generates its own =
       =20
         randomly-generated challenge string. The client then =
concatenates      =20
           the server's decoded challenge, a ":" character, its own =
challenge,  =20
               another ":" character, and the cookie. It computes the =
SHA-1 hash=20
                 of this composite string as a hex digest. It =
concatenates the  =20
               client's challenge string, a space character, and the =
SHA-1 hex  =20
               digest, hex-encodes the result and sends it back to the =
server.  =20
              </P></LI>
  <LI class=3D"listitem">
  <P>                The server generates the same concatenated string =
used by=20
  the                client and computes its SHA-1 hash. It compares the =
hash=20
  with                the hash received from the client; if the two =
hashes=20
  match, the                client is authenticated.              =20
</P></LI></UL></DIV>
<P></P>
<P>          Each server has a "cookie context," which is a name that =
identifies=20
a          set of cookies that apply to that server. A sample context =
might be  =20
       "org_freedesktop_session_bus". Context names must be valid ASCII, =
       =20
 nonzero length, and may not contain the characters slash ("/"),         =
=20
backslash ("\"), space (" "), newline ("\n"), carriage return ("\r"),    =
     =20
tab ("\t"), or period ("."). There is a default context,         =20
"org_freedesktop_general" that's used by servers that do not specify     =
    =20
otherwise.         </P>
<P>          Cookies are stored in a user's home directory, in the =
directory    =20
      <CODE class=3D"filename">~/.dbus-keyrings/</CODE>. This directory =
must      =20
    not be readable or writable by other users. If it is,           =
clients and=20
servers must ignore it. The directory           contains cookie files =
named=20
after the cookie context.         </P>
<P>          A cookie file contains one cookie per line. Each line       =
    has=20
three space-separated fields:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                The cookie ID number, which must be a non-negative =
integer=20
  and                may not be used twice in the same file.             =
 =20
  </P></LI>
  <LI class=3D"listitem">
  <P>                The cookie's creation time, in UNIX =
seconds-since-the-epoch=20
                 format.               </P></LI>
  <LI class=3D"listitem">
  <P>                The cookie itself, a hex-encoded random block of =
bytes. The=20
  cookie                may be of any length, though obviously security=20
  increases                 as the length increases.              =20
</P></LI></UL></DIV>
<P></P>
<P>          Only server processes modify the cookie file.          They =
must do=20
so with this procedure:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                Create a lockfile name by appending ".lock" to the =
name of=20
  the                cookie file.  The server should attempt to create =
this file=20
                 using <CODE class=3D"literal">O_CREAT | O_EXCL</CODE>.  =
If file=20
  creation                fails, the lock fails. Servers should retry =
for a=20
  reasonable                period of time, then they may choose to =
delete an=20
  existing lock                to keep users from having to manually =
delete a=20
  stale                lock. <A name=3D"idp56106992" class=3D"footnote" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#ftn.idp56=
106992"><SUP=20
  class=3D"footnote">[1]</SUP></A>               </P></LI>
  <LI class=3D"listitem">
  <P>                Once the lockfile has been created, the server =
loads the=20
  cookie                file. It should then delete any cookies that are =
old=20
  (the                timeout can be fairly short), or more than a =
reasonable   =20
              time in the future (so that cookies never accidentally     =
       =20
      become permanent, if the clock was set far into the future         =
       =20
  at some point). If no recent keys remain, the                 server =
may=20
  generate a new key.               </P></LI>
  <LI class=3D"listitem">
  <P>                The pruned and possibly added-to cookie file        =
       =20
   must be resaved atomically (using a temporary                 file =
which is=20
  rename()'d).               </P></LI>
  <LI class=3D"listitem">
  <P>                The lock must be dropped by deleting the lockfile.  =
       =20
       </P></LI></UL></DIV>
<P></P>
<P>          Clients need not lock the file in order to load it,         =
 =20
because servers are required to save the file atomically.                =
  =20
</P></DIV></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A =
name=3D"addresses"></A>Server=20
Addresses</H2></DIV></DIV></DIV>
<P>      Server addresses consist of a transport name followed by a =
colon, and  =20
   then an optional, comma-separated list of keys and values in the form =

key=3Dvalue.      Each value is escaped.     </P>
<P>      For example:        </P>
<PRE class=3D"programlisting">unix:path=3D/tmp/dbus-test</PRE>
<P>      Which is the address to a unix socket with the path =
/tmp/dbus-test.    =20
</P>
<P>      Value escaping is similar to URI escaping but simpler.       =
</P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>            The set of optionally-escaped bytes is:             =
<CODE=20
  class=3D"literal">[0-9A-Za-z_-/.\]</CODE>. To escape, each             =
<SPAN=20
  class=3D"emphasis"><EM>byte</EM></SPAN> (note, not character) which is =
not in=20
  the            set of optionally-escaped bytes must be replaced with =
an ASCII =20
            percent (<CODE class=3D"literal">%</CODE>) and the value of =
the byte=20
  in hex.            The hex value must always be two digits, even if =
the first=20
  digit is            zero. The optionally-escaped bytes may be escaped =
if=20
  desired.           </P></LI>
  <LI class=3D"listitem">
  <P>            To unescape, append each byte in the value; if a byte =
is an=20
  ASCII            percent (<CODE class=3D"literal">%</CODE>) character =
then=20
  append the following            hex value instead. It is an error if a =
<CODE=20
  class=3D"literal">%</CODE> byte            does not have two hex =
digits=20
  following. It is an error if a            non-optionally-escaped byte =
is seen=20
  unescaped.           </P></LI></UL></DIV>
<P>      The set of optionally-escaped bytes is intended to preserve =
address    =20
  readability and convenience.     </P>
<P>      A server may specify a key-value pair with the key <CODE =
class=3D"literal">guid</CODE>=20
     and the value a hex-encoded 16-byte sequence. <A title=3D"UUIDs" =
class=3D"xref"=20
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#uuids">th=
e section=20
called =93UUIDs=94</A>       describes the format of the <CODE=20
class=3D"literal">guid</CODE> field.  If present,      this UUID may be =
used to=20
distinguish one server address from another. A      server should use a=20
different UUID for each address it listens on. For      example, if a =
message=20
bus daemon offers both UNIX domain socket and TCP      connections, but =
treats=20
clients the same regardless of how they connect,      those two =
connections are=20
equivalent post-connection but should have      distinct UUIDs to =
distinguish=20
the kinds of connection.     </P>
<P>      The intent of the address UUID feature is to allow a client to =
avoid   =20
  opening multiple identical connections to the same server, by allowing =
the    =20
 client to check whether an address corresponds to an already-existing   =
  =20
connection.  Comparing two addresses is insufficient, because addresses  =
    can=20
be recycled by distinct servers, and equivalent addresses may look     =20
different if simply compared as strings (for example, the host in a TCP  =
   =20
address can be given as an IP address or as a hostname).     </P>
<P>      Note that the address key is <CODE =
class=3D"literal">guid</CODE> even=20
though the       rest of the API and documentation says "UUID," for =
historical=20
reasons.     </P>
<P>      [FIXME clarify if attempting to connect to each is a =
requirement      =20
or just a suggestion]      When connecting to a server, multiple server=20
addresses can be      separated by a semi-colon. The library will then =
try to=20
connect      to the first address and if that fails, it'll try to =
connect to    =20
 the next one specified, and so forth. For example       </P>
<PRE =
class=3D"programlisting">unix:path=3D/tmp/dbus-test;unix:path=3D/tmp/dbus=
-test2</PRE>
<P></P>
<P>      Some addresses are <EM class=3D"firstterm">connectable</EM>. A=20
connectable      address is one containing enough information for a =
client to=20
connect      to it. For instance, <CODE=20
class=3D"literal">tcp:host=3D127.0.0.1,port=3D4242</CODE>      is a =
connectable=20
address. It is not necessarily possible to listen      on every =
connectable=20
address: for instance, it is not possible to      listen on a <CODE =
class=3D"literal">unixexec:</CODE>=20
address.     </P>
<P>      Some addresses are <EM class=3D"firstterm">listenable</EM>. A =
listenable =20
    address is one containing enough information for a server to listen =
on     =20
it, producing a connectable address (which may differ from the      =
original=20
address). Many listenable addresses are not connectable:      for =
instance,=20
<CODE class=3D"literal">tcp:host=3D127.0.0.1</CODE>      is listenable, =
but not=20
connectable (because it does not specify      a port number).     </P>
<P>      Listening on an address that is not connectable will result in =
a     =20
connectable address that is not the same as the listenable address.      =
For=20
instance, listening on <CODE =
class=3D"literal">tcp:host=3D127.0.0.1</CODE>     =20
might result in the connectable address       <CODE=20
class=3D"literal">tcp:host=3D127.0.0.1,port=3D30958</CODE>,      or =
listening on <CODE=20
class=3D"literal">unix:tmpdir=3D/tmp</CODE>      might result in the =
connectable=20
address       <CODE =
class=3D"literal">unix:abstract=3D/tmp/dbus-U8OSdmf7</CODE>.    =20
</P></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"transports"></A>Transports</H2></DIV></DIV></DIV>
<P>      [FIXME we need to specify in detail each transport and its =
possible=20
arguments]          Current transports include: unix domain sockets =
(including  =20
    abstract namespace on linux), launchd, systemd, TCP/IP, an executed=20
subprocess and a debug/testing transport      using in-process pipes. =
Future=20
possible transports include one that      tunnels over X11 protocol.     =
</P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"transports-unix-domain-sockets"></A>Unix =
Domain=20
Sockets</H3></DIV></DIV></DIV>
<P>        Unix domain sockets can be either paths in the file system or =
on=20
Linux         kernels, they can be abstract which are similar to paths =
but      =20
 do not show up in the file system.       </P>
<P>        When a socket is opened by the D-Bus library it truncates the =
path   =20
     name right before the first trailing Nul byte.  This is true for =
both      =20
 normal paths and abstract paths.  Note that this is a departure from    =
   =20
previous versions of D-Bus that would create sockets with a fixed        =
length=20
path name.  Names which were shorter than the fixed length        would =
be=20
padded by Nul bytes.       </P>
<P>        Unix domain sockets are not available on Windows.       </P>
<P>        Unix addresses that specify <CODE =
class=3D"literal">path</CODE> or     =20
   <CODE class=3D"literal">abstract</CODE> are both listenable and =
connectable.   =20
    Unix addresses that specify <CODE class=3D"literal">tmpdir</CODE> =
are only    =20
   listenable: the corresponding connectable address will specify        =
either=20
<CODE class=3D"literal">path</CODE> or <CODE =
class=3D"literal">abstract</CODE>.     =20
 </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"transports-unix-domain-sockets-addresses"></A>Server=20
Address Format</H4></DIV></DIV></DIV>
<P>           Unix domain socket addresses are identified by the "unix:" =
prefix =20
         and support the following key/value pairs:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>path</TD>
    <TD>(path)</TD>
    <TD>path of the unix domain socket. If set, the "tmpdir" and =
"abstract"=20
      key must not be set.</TD></TR>
  <TR>
    <TD>tmpdir</TD>
    <TD>(path)</TD>
    <TD>temporary directory in which a socket file with a random file =
name=20
      starting with 'dbus-' will be created by the server. This key can =
only be=20
      used in server addresses, not in client addresses. If set, the =
"path" and=20
      "abstract" key must not be set.</TD></TR>
  <TR>
    <TD>abstract</TD>
    <TD>(string)</TD>
    <TD>unique string (path) in the abstract namespace. If set, the =
"path" or=20
      "tmpdir" key must not be set. This key is only supported on =
platforms with=20
      "abstract Unix sockets", of which Linux is the only known=20
  example.</TD></TR></TBODY></TABLE></DIV>
<P>         Exactly one of the keys <CODE class=3D"literal">path</CODE>, =
        =20
<CODE class=3D"literal">abstract</CODE> or          <CODE=20
class=3D"literal">tmpdir</CODE> must be provided.        =
</P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A=20
name=3D"transports-launchd"></A>launchd</H3></DIV></DIV></DIV>
<P>        launchd is an open-source server management system that =
replaces=20
init, inetd        and cron on Apple Mac OS X versions 10.4 and above. =
It=20
provides a common session        bus address for each user and =
deprecates the=20
X11-enabled D-Bus launcher on OSX.       </P>
<P>        launchd allocates a socket and provides it with the unix path =
through=20
the        DBUS_LAUNCHD_SESSION_BUS_SOCKET variable in launchd's =
environment.=20
Every process        spawned by launchd (or dbus-daemon, if it was =
started by=20
launchd) can access        it through its environment.        Other =
processes=20
can query for the launchd socket by executing:        $ launchctl getenv =

DBUS_LAUNCHD_SESSION_BUS_SOCKET        This is normally done by the =
D-Bus client=20
library so doesn't have to be done        manually.       </P>
<P>        launchd is not available on Microsoft Windows.       </P>
<P>        launchd addresses are listenable and connectable.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"transports-launchd-addresses"></A>Server =
Address=20
Format</H4></DIV></DIV></DIV>
<P>          launchd addresses are identified by the "launchd:" prefix   =
      =20
and support the following key/value pairs:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>env</TD>
    <TD>(environment variable)</TD>
    <TD>path of the unix domain socket for the launchd created=20
  dbus-daemon.</TD></TR></TBODY></TABLE></DIV>
<P>         The <CODE class=3D"literal">env</CODE> key is required.      =
 =20
</P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A=20
name=3D"transports-systemd"></A>systemd</H3></DIV></DIV></DIV>
<P>        systemd is an open-source server management system that       =
=20
replaces init and inetd on newer Linux systems. It supports        =
socket=20
activation. The D-Bus systemd transport is used to acquire        socket =

activation file descriptors from systemd and use them        as D-Bus =
transport=20
when the current process is spawned by        socket activation from it. =
     =20
</P>
<P>        The systemd transport accepts only one or more Unix domain or =
      =20
TCP streams sockets passed in via socket activation.       </P>
<P>        The systemd transport is not available on non-Linux operating =

systems.       </P>
<P>        The systemd transport defines no parameter keys.       </P>
<P>        systemd addresses are listenable, but not connectable. The    =
   =20
corresponding connectable address is the <CODE =
class=3D"literal">unix</CODE>      =20
 or <CODE class=3D"literal">tcp</CODE> address of the socket.       =
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"transports-tcp-sockets"></A>TCP=20
Sockets</H3></DIV></DIV></DIV>
<P>        The tcp transport provides TCP/IP based connections between =
clients  =20
     located on the same or different hosts.        </P>
<P>        Using tcp transport without any additional secure =
authentification=20
mechanismus         over a network is unsecure.        </P>
<P>          On Windows and most Unix platforms, the TCP stack is unable =
to=20
transfer        credentials over a TCP connection, so the EXTERNAL=20
authentication        mechanism does not work for this transport.       =
</P>
<P>        All <CODE class=3D"literal">tcp</CODE> addresses are =
listenable.       =20
 <CODE class=3D"literal">tcp</CODE> addresses in which both         =
<CODE class=3D"literal">host</CODE>=20
and <CODE class=3D"literal">port</CODE> are        specified, and <CODE =
class=3D"literal">port</CODE>=20
is non-zero,        are also connectable.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"transports-tcp-sockets-addresses"></A>Server Address=20
Format</H4></DIV></DIV></DIV>
<P>          TCP/IP socket addresses are identified by the "tcp:" prefix =
       =20
 and support the following key/value pairs:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>host</TD>
    <TD>(string)</TD>
    <TD>DNS name or IP address</TD></TR>
  <TR>
    <TD>bind</TD>
    <TD>(string)</TD>
    <TD>Used in a listenable address to configure the interface          =
  on=20
      which the server will listen: either the IP address of one of      =
     =20
      the local machine's interfaces (most commonly <CODE=20
      class=3D"literal">127.0.0.1             </CODE>), or a DNS name =
that=20
      resolves to one of those IP            addresses, or '*' to listen =
on all=20
      interfaces simultaneously.            If not specified, the =
default is the=20
      same value as "host".            </TD></TR>
  <TR>
    <TD>port</TD>
    <TD>(number)</TD>
    <TD>The tcp port the server will open. A zero value let the server   =
     =20
          choose a free port provided from the underlaying operating =
system.    =20
              libdbus is able to retrieve the real used port from the =
server.   =20
                </TD></TR>
  <TR>
    <TD>family</TD>
    <TD>(string)</TD>
    <TD>If set, provide the type of socket family either "ipv4" or =
"ipv6". If=20
      unset, the family is =
unspecified.</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"transports-nonce-tcp-sockets"></A>Nonce-secured TCP=20
Sockets</H3></DIV></DIV></DIV>
<P>        The nonce-tcp transport provides a secured TCP transport, =
using a    =20
   simple authentication mechanism to ensure that only clients with read =
      =20
access to a certain location in the filesystem can connect to the =
server.       =20
The server writes a secret, the nonce, to a file and an incoming client  =
     =20
connection is only accepted if the client sends the nonce right after    =
    the=20
connect. The nonce mechanism requires no setup and is orthogonal to      =
  the=20
higher-level authentication mechanisms described in the        =
Authentication=20
section.       </P>
<P>        On start, the server generates a random 16 byte nonce and =
writes it  =20
     to a file in the user's temporary directory. The nonce file =
location       =20
is published as part of the server's D-Bus address using the        =
"noncefile"=20
key-value pair.        After an accept, the server reads 16 bytes from =
the=20
socket. If the        read bytes do not match the nonce stored in the =
nonce=20
file, the        server MUST immediately drop the connection.        If =
the=20
nonce match the received byte sequence, the client is accepted        =
and the=20
transport behaves like an unsecured tcp transport.       </P>
<P>        After a successful connect to the server socket, the client =
MUST read=20
       the nonce from the file published by the server via the =
noncefile=3D       =20
key-value pair and send it over the socket. After that, the        =
transport=20
behaves like an unsecured tcp transport.       </P>
<P>        All nonce-tcp addresses are listenable. nonce-tcp addresses =
in which =20
       <CODE class=3D"literal">host</CODE>, <CODE =
class=3D"literal">port</CODE> and =20
       <CODE class=3D"literal">noncefile</CODE> are all specified,       =
 and=20
<CODE class=3D"literal">port</CODE> is nonzero, are also connectable.    =
   </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"transports-nonce-tcp-sockets-addresses"></A>Server=20
Address Format</H4></DIV></DIV></DIV>
<P>          Nonce TCP/IP socket addresses uses the "nonce-tcp:" prefix  =
       =20
and support the following key/value pairs:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>host</TD>
    <TD>(string)</TD>
    <TD>DNS name or IP address</TD></TR>
  <TR>
    <TD>bind</TD>
    <TD>(string)</TD>
    <TD>The same as for tcp: addresses            </TD></TR>
  <TR>
    <TD>port</TD>
    <TD>(number)</TD>
    <TD>The tcp port the server will open. A zero value let the server   =
     =20
          choose a free port provided from the underlaying operating =
system.    =20
              libdbus is able to retrieve the real used port from the =
server.   =20
                </TD></TR>
  <TR>
    <TD>family</TD>
    <TD>(string)</TD>
    <TD>If set, provide the type of socket family either "ipv4" or =
"ipv6". If=20
      unset, the family is unspecified.</TD></TR>
  <TR>
    <TD>noncefile</TD>
    <TD>(path)</TD>
    <TD>File location containing the secret.             This is only=20
      meaningful in connectable addresses:             a listening D-Bus =
server=20
      that offers this transport             will always create a new =
nonce=20
    file.</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"transports-exec"></A>Executed =
Subprocesses on=20
Unix</H3></DIV></DIV></DIV>
<P>        This transport forks off a process and connects its standard  =
     =20
input and standard output with an anonymous Unix domain        socket. =
This=20
socket is then used for communication by the        transport. This =
transport=20
may be used to use out-of-process        forwarder programs as basis for =
the=20
D-Bus protocol.       </P>
<P>        The forked process will inherit the standard error output and =
      =20
process group from the parent process.       </P>
<P>        Executed subprocesses are not available on Windows.       =
</P>
<P><CODE class=3D"literal">unixexec</CODE> addresses are connectable, =
but are not =20
      listenable.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"transports-exec-addresses"></A>Server =
Address=20
Format</H4></DIV></DIV></DIV>
<P>          Executed subprocess addresses are identified by the =
"unixexec:"=20
prefix          and support the following key/value pairs:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>path</TD>
    <TD>(path)</TD>
    <TD>Path of the binary to execute, either an absolute            =
path or a=20
      binary name that is searched for in the default            search =
path of=20
      the OS. This corresponds to the first            argument of =
execlp().=20
      This key is mandatory.</TD></TR>
  <TR>
    <TD>argv0</TD>
    <TD>(string)</TD>
    <TD>The program name to use when executing the            binary. If =

      omitted the same value as specified for path=3D            will be =
used.=20
      This corresponds to the second argument of            =
execlp().</TD></TR>
  <TR>
    <TD>argv1, argv2, ...</TD>
    <TD>(string)</TD>
    <TD>Arguments to pass to the binary. This corresponds            to =
the=20
      third and later arguments of execlp(). If a            specific =
argvX is=20
      not specified no further argvY for Y &gt; X            are taken =
into=20
      account.</TD></TR></TBODY></TABLE></DIV></DIV></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A =
name=3D"meta-transports"></A>Meta=20
Transports</H2></DIV></DIV></DIV>
<P>      Meta transports are a kind of transport with special =
enhancements or   =20
  behavior. Currently available meta transports include: autolaunch     =
</P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A=20
name=3D"meta-transports-autolaunch"></A>Autolaunch</H3></DIV></DIV></DIV>=

<P>The autolaunch transport provides a way for dbus clients to =
autodetect      =20
a running dbus session bus and to autolaunch a session bus if not =
present.     =20
</P>
<P>        On Unix, <CODE class=3D"literal">autolaunch</CODE> addresses =
are=20
connectable,        but not listenable.       </P>
<P>        On Windows, <CODE class=3D"literal">autolaunch</CODE> =
addresses are=20
both        connectable and listenable.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"meta-transports-autolaunch-addresses"></A>Server=20
Address Format</H4></DIV></DIV></DIV>
<P>         Autolaunch addresses uses the "autolaunch:" prefix and =
support the  =20
      following key/value pairs:        </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>scope</TD>
    <TD>(string)</TD>
    <TD>scope of autolaunch (Windows only)            =20
      <DIV class=3D"itemizedlist">
      <UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
        <LI class=3D"listitem">
        <P>               "*install-path" - limit session bus to dbus=20
        installation path.               The dbus installation path is=20
        determined from the location of               the shared dbus =
library.=20
        If the library is located in a 'bin'               subdirectory =
the=20
        installation root is the directory above,               =
otherwise the=20
        directory where the library lives is taken as               =
installation=20
        root.                </P>
<PRE class=3D"programlisting">                   =
&lt;install-root&gt;/bin/[lib]dbus-1.dll=0A=
                   &lt;install-root&gt;/[lib]dbus-1.dll=0A=
               </PRE>
        <P></P></LI>
        <LI class=3D"listitem">
        <P>               "*user" - limit session bus to the recent =
user.       =20
               </P></LI>
        <LI class=3D"listitem">
        <P>               other values - specify dedicated session bus =
like=20
        "release",               "debug" or other              =20
      </P></LI></UL></DIV></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A=20
name=3D"meta-transports-autolaunch-windows-implementation"></A>Windows=20
implementation</H4></DIV></DIV></DIV>
<P>        On start, the server opens a platform specific transport, =
creates a=20
mutex        and a shared memory section containing the related session =
bus=20
address.        This mutex will be inspected by the dbus client library =
to=20
detect a        running dbus session bus. The access to the mutex and =
the shared=20
memory        section are protected by global locks.       </P>
<P>       In the recent implementation the autolaunch transport uses a =
tcp=20
transport       on localhost with a port choosen from the operating =
system. This=20
detail may       change in the future.       </P>
<P>        Disclaimer: The recent implementation is in an early state =
and may=20
not        work in all cirumstances and/or may have security issues. =
Because of=20
this        the implementation is not documentated yet.      =20
</P></DIV></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"uuids"></A>UUIDs</H2></DIV></DIV></DIV>
<P>      A working D-Bus implementation uses universally-unique IDs in =
two=20
places.      First, each server address has a UUID identifying the =
address,     =20
 as described in <A title=3D"Server Addresses" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#addresses=
">the=20
section called =93Server Addresses=94</A>. Second, each operating      =
system kernel=20
instance running a D-Bus client or server has a UUID      identifying =
that=20
kernel, retrieved by invoking the method     =20
org.freedesktop.DBus.Peer.GetMachineId() (see <A =
title=3D"org.freedesktop.DBus.Peer"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-peer">the=20
section called =93<CODE =
class=3D"literal">org.freedesktop.DBus.Peer</CODE>=94</A>).   =20
 </P>
<P>The term "UUID" in this document is intended literally, i.e. an     =20
identifier that is universally unique. It is not intended to refer to    =
 =20
RFC4122, and in fact the D-Bus UUID is not compatible with that RFC.     =
</P>
<P>      The UUID must contain 128 bits of data and be hex-encoded.  The =
    =20
hex-encoded string may not contain hyphens or other non-hex-digit     =20
characters, and it must be exactly 32 characters long.  To generate a    =
  UUID,=20
the current reference implementation concatenates 96 bits of random      =
data=20
followed by the 32-bit time in seconds since the UNIX epoch (in big      =
endian=20
byte order).     </P>
<P>      It would also be acceptable and probably better to simply =
generate 128 =20
    bits of random data, as long as the random number generator is of =
high     =20
quality. The timestamp could conceivably help if the random bits are not =
    =20
very random. With a quality random number generator, collisions are      =

extremely unlikely even with only 96 bits, so it's somewhat academic.    =
 </P>
<P>      Implementations should, however, stick to random data for the =
first 96=20
bits      of the UUID.     </P></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"standard-interfaces"></A>Standard =
Interfaces</H2></DIV></DIV></DIV>
<P>      See <A title=3D"Notation in this document" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-types-notation">the=20
section called =93Notation in this document=94</A> for details on        =
the=20
notation used in this section. There are some standard interfaces      =
that may=20
be useful across various D-Bus applications.     </P>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"standard-interfaces-peer"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.Peer</CODE></H3></DIV></DIV></DIV>=

<P>        The <CODE class=3D"literal">org.freedesktop.DBus.Peer</CODE> =
interface =20
       has two methods:         </P>
<PRE class=3D"programlisting">          org.freedesktop.DBus.Peer.Ping ()=0A=
          org.freedesktop.DBus.Peer.GetMachineId (out STRING =
machine_uuid)=0A=
        </PRE>
<P></P>
<P>        On receipt of the <CODE class=3D"literal">METHOD_CALL</CODE> =
message   =20
     <CODE class=3D"literal">org.freedesktop.DBus.Peer.Ping</CODE>, an =
application=20
should do        nothing other than reply with a <CODE=20
class=3D"literal">METHOD_RETURN</CODE> as        usual.  It does not =
matter which=20
object path a ping is sent to.  The        reference implementation =
handles this=20
method automatically.       </P>
<P>        On receipt of the <CODE class=3D"literal">METHOD_CALL</CODE> =
message   =20
     <CODE =
class=3D"literal">org.freedesktop.DBus.Peer.GetMachineId</CODE>, an=20
application should         reply with a <CODE=20
class=3D"literal">METHOD_RETURN</CODE> containing a hex-encoded         =
UUID=20
representing the identity of the machine the process is running on.      =
  This=20
UUID must be the same for all processes on a single system at least      =
  until=20
that system next reboots. It should be the same across reboots         =
if=20
possible, but this is not always possible to implement and is not        =
=20
guaranteed.        It does not matter which object path a GetMachineId =
is sent=20
to.  The        reference implementation handles this method =
automatically.     =20
 </P>
<P>        The UUID is intended to be =
per-instance-of-the-operating-system, so=20
may represent        a virtual machine running on a hypervisor, rather =
than a=20
physical machine.        Basically if two processes see the same UUID, =
they=20
should also see the same        shared memory, UNIX domain sockets, =
process IDs,=20
and other features that require         a running OS kernel in common =
between=20
the processes.       </P>
<P>        The UUID is often used where other programs might use a =
hostname.=20
Hostnames         can change without rebooting, however, or just be =
"localhost"=20
- so the UUID        is more robust.       </P>
<P><A title=3D"UUIDs" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#uuids">th=
e=20
section called =93UUIDs=94</A> explains the format of the UUID.       =
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"standard-interfaces-introspectable"></A><CODE =
class=3D"literal">org.freedesktop.DBus.Introspectable</CODE></H3></DIV></=
DIV></DIV>
<P>        This interface has one method:         </P>
<PRE class=3D"programlisting">          =
org.freedesktop.DBus.Introspectable.Introspect (out STRING xml_data)=0A=
        </PRE>
<P></P>
<P>        Objects instances may implement         <CODE=20
class=3D"literal">Introspect</CODE> which returns an XML description of  =
      the=20
object, including its interfaces (with signals and methods), objects     =
  =20
below it in the object path tree, and its properties.       </P>
<P><A title=3D"Introspection Data Format" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#introspec=
tion-format">the=20
section called =93Introspection Data Format=94</A> describes the format =
of this XML=20
string.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"standard-interfaces-properties"></A><CODE =
class=3D"literal">org.freedesktop.DBus.Properties</CODE></H3></DIV></DIV>=
</DIV>
<P>        Many native APIs will have a concept of object <EM=20
class=3D"firstterm">properties</EM>         or <EM=20
class=3D"firstterm">attributes</EM>. These can be exposed via the        =
  <CODE=20
class=3D"literal">org.freedesktop.DBus.Properties</CODE> interface.      =
 </P>
<P></P>
<PRE class=3D"programlisting">              =
org.freedesktop.DBus.Properties.Get (in STRING interface_name,=0A=
                                                   in STRING =
property_name,=0A=
                                                   out VARIANT value);=0A=
              org.freedesktop.DBus.Properties.Set (in STRING =
interface_name,=0A=
                                                   in STRING =
property_name,=0A=
                                                   in VARIANT value);=0A=
              org.freedesktop.DBus.Properties.GetAll (in STRING =
interface_name,=0A=
                                                      out =
DICT&lt;STRING,VARIANT&gt; props);=0A=
        </PRE>
<P></P>
<P>        It is conventional to give D-Bus properties names consisting =
of      =20
 capitalized words without punctuation ("CamelCase"), like         <A =
title=3D"Member names"=20
class=3D"link" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-member">member=20
names</A>.        For instance, the GObject property         <CODE =
class=3D"literal">connection-status</CODE>=20
or the Qt property         <CODE =
class=3D"literal">connectionStatus</CODE> could=20
be represented on D-Bus        as <CODE =
class=3D"literal">ConnectionStatus</CODE>.=20
      </P>
<P>        Strictly speaking, D-Bus property names are not required to =
follow   =20
    the same naming restrictions as member names, but D-Bus property     =
  =20
names that would not be valid member names (in particular,        =
GObject-style=20
dash-separated property names) can cause interoperability        =
problems and=20
should be avoided.       </P>
<P>        The available properties and whether they are writable can be =

determined        by calling <CODE=20
class=3D"literal">org.freedesktop.DBus.Introspectable.Introspect</CODE>, =
      =20
see <A title=3D"org.freedesktop.DBus.Introspectable" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-introspectable">the=20
section called =93<CODE=20
class=3D"literal">org.freedesktop.DBus.Introspectable</CODE>=94</A>.     =
  </P>
<P>An empty string may be provided for the interface name; in this case, =
       =20
if there are multiple properties on an object with the same name,        =
 the=20
results are undefined (picking one by according to an arbitrary        =20
deterministic rule, or returning an error, are the reasonable        =20
possibilities).       </P>
<P>        If one or more properties change on an object, the         =
<CODE=20
class=3D"literal">org.freedesktop.DBus.Properties.PropertiesChanged</CODE=
>       =20
signal may be emitted (this signal was added in 0.14):       </P>
<P></P>
<PRE class=3D"programlisting">              =
org.freedesktop.DBus.Properties.PropertiesChanged (STRING interface_name,=0A=
                                                                 =
DICT&lt;STRING,VARIANT&gt; changed_properties,=0A=
                                                                 =
ARRAY&lt;STRING&gt; invalidated_properties);=0A=
        </PRE>
<P></P>
<P>        where <CODE class=3D"literal">changed_properties</CODE> is a =
dictionary=20
       containing the changed properties with the new values and         =
<CODE=20
class=3D"literal">invalidated_properties</CODE> is an array of        =
properties=20
that changed but the value is not conveyed.       </P>
<P>        Whether the <CODE class=3D"literal">PropertiesChanged</CODE> =
signal is =20
      supported can be determined by calling         <CODE=20
class=3D"literal">org.freedesktop.DBus.Introspectable.Introspect</CODE>. =
Note     =20
  that the signal may be supported for an object but it may        =
differ how=20
whether and how it is used on a per-property basis        (for e.g. =
performance=20
or security reasons). Each property (or        the parent interface) =
must be=20
annotated with the         <CODE=20
class=3D"literal">org.freedesktop.DBus.Property.EmitsChangedSignal</CODE>=
       =20
annotation to convey this (usually the default value         <CODE =
class=3D"literal">true</CODE>=20
is sufficient meaning that the        annotation does not need to be =
used). See=20
<A title=3D"Introspection Data Format" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#introspec=
tion-format">the=20
section called =93Introspection Data Format=94</A> for details on this   =
    =20
annotation.       </P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"standard-interfaces-objectmanager"></A><CODE =
class=3D"literal">org.freedesktop.DBus.ObjectManager</CODE></H3></DIV></D=
IV></DIV>
<P>        An API can optionally make use of this interface for one or   =
    =20
more sub-trees of objects. The root of each sub-tree implements        =
this=20
interface so other applications can get all objects,        interfaces =
and=20
properties in a single method call.  It is        appropriate to use =
this=20
interface if users of the tree of        objects are expected to be =
interested=20
in all interfaces of all        objects in the tree; a more granular API =
should=20
be used if        users of the objects are expected to be interested in =
a small =20
      subset of the objects, a small subset of their interfaces, or      =
  both.=20
      </P>
<P>        The method that applications can use to get all objects and   =
    =20
properties is <CODE class=3D"literal">GetManagedObjects</CODE>:       =
</P>
<P></P>
<PRE class=3D"programlisting">          =
org.freedesktop.DBus.ObjectManager.GetManagedObjects (out =
DICT&lt;OBJPATH,DICT&lt;STRING,DICT&lt;STRING,VARIANT&gt;&gt;&gt; =
objpath_interfaces_and_properties);=0A=
        </PRE>
<P></P>
<P>        The return value of this method is a dict whose keys are      =
 =20
object paths. All returned object paths are children of the        =
object path=20
implementing this interface, i.e. their object        paths start with =
the=20
ObjectManager's object path plus '/'.       </P>
<P>        Each value is a dict whose keys are interfaces names.  Each   =
    =20
value in this inner dict is the same dict that would be        returned =
by the=20
<A title=3D"org.freedesktop.DBus.Properties" class=3D"link" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-properties">org.freedesktop.DBus.Properties.GetAll()</A>=20
       method for that combination of object path and interface. If      =
  an=20
interface has no properties, the empty dict is returned.       </P>
<P>        Changes are emitted using the following two signals:       =
</P>
<P></P>
<PRE class=3D"programlisting">          =
org.freedesktop.DBus.ObjectManager.InterfacesAdded (OBJPATH object_path,=0A=
                                                              =
DICT&lt;STRING,DICT&lt;STRING,VARIANT&gt;&gt; interfaces_and_properties);=0A=
          org.freedesktop.DBus.ObjectManager.InterfacesRemoved (OBJPATH =
object_path,=0A=
                                                                =
ARRAY&lt;STRING&gt; interfaces);=0A=
        </PRE>
<P></P>
<P>        The <CODE class=3D"literal">InterfacesAdded</CODE> signal is =
emitted=20
when        either a new object is added or when an existing object =
gains       =20
one or more interfaces. The         <CODE=20
class=3D"literal">InterfacesRemoved</CODE> signal is emitted        =
whenever an=20
object is removed or it loses one or more        interfaces. The second=20
parameter of the         <CODE class=3D"literal">InterfacesAdded</CODE> =
signal=20
contains a dict with        the interfaces and properties (if any) that =
have=20
been added to        the given object path. Similarly, the second =
parameter of=20
the         <CODE class=3D"literal">InterfacesRemoved</CODE> signal =
contains an=20
array        of the interfaces that were removed. Note that changes on   =
    =20
properties on existing interfaces are not reported using this        =
interface -=20
an application should also monitor the existing <A =
title=3D"org.freedesktop.DBus.Properties"=20
class=3D"link" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-properties">PropertiesChanged</A>=20
       signal on each object.       </P>
<P>        Applications SHOULD NOT export objects that are children of =
an       =20
object (directly or otherwise) implementing this interface but        =
which are=20
not returned in the reply from the         <CODE=20
class=3D"literal">GetManagedObjects()</CODE> method of this        =
interface on=20
the given object.       </P>
<P>        The intent of the <CODE =
class=3D"literal">ObjectManager</CODE>=20
interface        is to make it easy to write a robust client       =20
implementation. The trivial client implementation only needs        to =
make two=20
method calls:       </P>
<P></P>
<PRE class=3D"programlisting">          org.freedesktop.DBus.AddMatch =
(bus_proxy,=0A=
                                         =
"type=3D'signal',name=3D'org.example.App',path_namespace=3D'/org/example/=
App'");=0A=
          objects =3D =
org.freedesktop.DBus.ObjectManager.GetManagedObjects (app_proxy);=0A=
        </PRE>
<P></P>
<P>        on the message bus and the remote application's         <CODE =
class=3D"literal">ObjectManager</CODE>,=20
respectively. Whenever a new        remote object is created (or an =
existing=20
object gains a new        interface), the <CODE=20
class=3D"literal">InterfacesAdded</CODE> signal is        emitted, and =
since this=20
signal contains all properties for the        interfaces, no calls to =
the       =20
 <CODE class=3D"literal">org.freedesktop.Properties</CODE> interface on =
the       =20
remote object are needed. Additionally, since the initial         <CODE =
class=3D"literal">AddMatch()</CODE>=20
rule already includes signal        messages from the newly created =
child=20
object, no new         <CODE class=3D"literal">AddMatch()</CODE> call is =
needed.  =20
    </P>
<P><SPAN class=3D"emphasis"><EM>          The <CODE=20
class=3D"literal">org.freedesktop.DBus.ObjectManager</CODE>          =
interface was=20
added in version 0.17 of the D-Bus          specification.         =
</EM></SPAN> =20
     </P></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A=20
name=3D"introspection-format"></A>Introspection Data =
Format</H2></DIV></DIV></DIV>
<P>      As described in <A =
title=3D"org.freedesktop.DBus.Introspectable" class=3D"xref"=20
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-introspectable">the=20
section called =93<CODE=20
class=3D"literal">org.freedesktop.DBus.Introspectable</CODE>=94</A>,     =
   objects=20
may be introspected at runtime, returning an XML string       that =
describes the=20
object. The same XML format may be used in       other contexts as well, =
for=20
example as an "IDL" for generating       static language bindings.     =
</P>
<P>      Here is an example of introspection data:       </P>
<PRE class=3D"programlisting">        &lt;!DOCTYPE node PUBLIC =
"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"=0A=
         =
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd"&gt;=0A=
        &lt;node name=3D"/com/example/sample_object"&gt;=0A=
          &lt;interface name=3D"com.example.SampleInterface"&gt;=0A=
            &lt;method name=3D"Frobate"&gt;=0A=
              &lt;arg name=3D"foo" type=3D"i" direction=3D"in"/&gt;=0A=
              &lt;arg name=3D"bar" type=3D"s" direction=3D"out"/&gt;=0A=
              &lt;arg name=3D"baz" type=3D"a{us}" direction=3D"out"/&gt;=0A=
              &lt;annotation name=3D"org.freedesktop.DBus.Deprecated" =
value=3D"true"/&gt;=0A=
            &lt;/method&gt;=0A=
            &lt;method name=3D"Bazify"&gt;=0A=
              &lt;arg name=3D"bar" type=3D"(iiu)" direction=3D"in"/&gt;=0A=
              &lt;arg name=3D"bar" type=3D"v" direction=3D"out"/&gt;=0A=
            &lt;/method&gt;=0A=
            &lt;method name=3D"Mogrify"&gt;=0A=
              &lt;arg name=3D"bar" type=3D"(iiav)" direction=3D"in"/&gt;=0A=
            &lt;/method&gt;=0A=
            &lt;signal name=3D"Changed"&gt;=0A=
              &lt;arg name=3D"new_value" type=3D"b"/&gt;=0A=
            &lt;/signal&gt;=0A=
            &lt;property name=3D"Bar" type=3D"y" =
access=3D"readwrite"/&gt;=0A=
          &lt;/interface&gt;=0A=
          &lt;node name=3D"child_of_sample_object"/&gt;=0A=
          &lt;node name=3D"another_child_of_sample_object"/&gt;=0A=
       &lt;/node&gt;=0A=
      </PRE>
<P></P>
<P>      A more formal DTD and spec needs writing, but here are some =
quick=20
notes.       </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>            Only the root &lt;node&gt; element can omit the node =
name, as=20
  it's            known to be the object that was introspected.  If the =
root    =20
         &lt;node&gt; does have a name attribute, it must be an absolute =
       =20
     object path. If child &lt;node&gt; have object paths, they must be  =
       =20
    relative.           </P></LI>
  <LI class=3D"listitem">
  <P>            If a child &lt;node&gt; has any sub-elements, then they =
       =20
      must represent a complete introspection of the child.            =
If a=20
  child &lt;node&gt; is empty, then it may or may             not have=20
  sub-elements; the child must be introspected            in order to =
find out.=20
  The intent is that if an object             knows that its children =
are "fast"=20
  to introspect            it can go ahead and return their information, =
but    =20
          otherwise it can omit it.           </P></LI>
  <LI class=3D"listitem">
  <P>            The direction element on &lt;arg&gt; may be omitted,    =
       =20
   in which case it defaults to "in" for method calls             and =
"out" for=20
  signals. Signals only allow "out"             so while direction may =
be=20
  specified, it's pointless.           </P></LI>
  <LI class=3D"listitem">
  <P>            The possible directions are "in" and "out",             =
unlike=20
  CORBA there is no "inout"           </P></LI>
  <LI class=3D"listitem">
  <P>            The possible property access flags are             =
"readwrite",=20
  "read", and "write"           </P></LI>
  <LI class=3D"listitem">
  <P>            Multiple interfaces can of course be listed for         =
    one=20
  &lt;node&gt;.           </P></LI>
  <LI class=3D"listitem">
  <P>            The "name" attribute on arguments is optional.          =
=20
  </P></LI></UL></DIV>
<P></P>
<P>        Method, interface, property, and signal elements may have     =
  =20
"annotations", which are generic key/value pairs of metadata.        =
They are=20
similar conceptually to Java's annotations and C# attributes.        =
Well-known=20
annotations:      </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Name</TH>
    <TH>Values (separated by ,)</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>org.freedesktop.DBus.Deprecated</TD>
    <TD>true,false</TD>
    <TD>Whether or not the entity is deprecated; defaults to =
false</TD></TR>
  <TR>
    <TD>org.freedesktop.DBus.GLib.CSymbol</TD>
    <TD>(string)</TD>
    <TD>The C symbol; may be used for methods and interfaces</TD></TR>
  <TR>
    <TD>org.freedesktop.DBus.Method.NoReply</TD>
    <TD>true,false</TD>
    <TD>If set, don't expect a reply to the method call; defaults to=20
  false.</TD></TR>
  <TR>
    <TD>org.freedesktop.DBus.Property.EmitsChangedSignal</TD>
    <TD>true,invalidates,false</TD>
    <TD>
      <P>                 If set to <CODE =
class=3D"literal">false</CODE>, the     =20
                  <CODE=20
      =
class=3D"literal">org.freedesktop.DBus.Properties.PropertiesChanged</CODE=
>  =20
                    signal, see <A =
title=3D"org.freedesktop.DBus.Properties"=20
      class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-properties">the=20
      section called =93<CODE=20
      class=3D"literal">org.freedesktop.DBus.Properties</CODE>=94</A> is =
not        =20
              guaranteed to be emitted if the property changes.          =
     =20
      </P>
      <P>                 If set to <CODE =
class=3D"literal">invalidates</CODE> the=20
      signal                 is emitted but the value is not included in =
the    =20
                  signal.                </P>
      <P>                 If set to <CODE class=3D"literal">true</CODE> =
the signal=20
      is                 emitted with the value included.                =
</P>
      <P>                 The value for the annotation defaults to       =
       =20
         <CODE class=3D"literal">true</CODE> if the enclosing interface  =
         =20
           element does not specify the annotation. Otherwise it         =
       =20
      defaults to the value specified in the enclosing                 =
interface=20
      element.                </P></TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=3D"sect1">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title" style=3D"clear: both;"><A =
name=3D"message-bus"></A>Message Bus=20
Specification</H2></DIV></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-bus-overview"></A>Message Bus=20
Overview</H3></DIV></DIV></DIV>
<P>        The message bus accepts connections from one or more =
applications.   =20
     Once connected, applications can exchange messages with other       =
 =20
applications that are also connected to the bus.       </P>
<P>        In order to route messages among connections, the message bus =
keeps a=20
       mapping from names to connections. Each connection has one        =

unique-for-the-lifetime-of-the-bus name automatically assigned.       =20
Applications may request additional names for a connection. Additional   =
    =20
names are usually "well-known names" such as        =
"com.example.TextEditor".=20
When a name is bound to a connection,        that connection is said to =
<EM=20
class=3D"firstterm">own</EM> the name.       </P>
<P>        The bus itself owns a special name,         <CODE=20
class=3D"literal">org.freedesktop.DBus</CODE>, with an object        =
located at=20
<CODE class=3D"literal">/org/freedesktop/DBus</CODE> that        =
implements the=20
<CODE class=3D"literal">org.freedesktop.DBus</CODE>        interface. =
This service=20
allows applications to make        administrative requests of the bus =
itself.=20
For example,        applications can ask the bus to assign a name to a=20
connection.       </P>
<P>        Each name may have <EM class=3D"firstterm">queued =
owners</EM>.  When an=20
       application requests a name for a connection and the name is =
already in  =20
     use, the bus will optionally add the connection to a queue waiting =
for     =20
   the name. If the current owner of the name disconnects or releases    =
    the=20
name, the next connection in the queue will become the new owner.       =
</P>
<P>        This feature causes the right thing to happen if you start =
two text  =20
     editors for example; the first one may request =
"com.example.TextEditor",   =20
    and the second will be queued as a possible owner of that name. When =
       =20
the first exits, the second will take over.       </P>
<P>        Applications may send <EM class=3D"firstterm">unicast =
messages</EM> to =20
      a specific recipient or to the message bus itself, or         <EM =
class=3D"firstterm">broadcast=20
messages</EM> to all interested recipients.        See <A =
title=3D"Message Bus Message Routing"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing">the=20
section called =93Message Bus Message Routing=94</A> for details.       =
</P></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-bus-names"></A>Message Bus=20
Names</H3></DIV></DIV></DIV>
<P>        Each connection has at least one name, assigned at connection =
time=20
and        returned in response to the         <CODE=20
class=3D"literal">org.freedesktop.DBus.Hello</CODE> method call.  This   =
    =20
automatically-assigned name is called the connection's <EM=20
class=3D"firstterm">unique        name</EM>.  Unique names are never =
reused for=20
two different        connections to the same bus.       </P>
<P>        Ownership of a unique name is a prerequisite for interaction =
with    =20
    the message bus. It logically follows that the unique name is always =
       =20
the first name that an application comes to own, and the last         =
one that=20
it loses ownership of.       </P>
<P>        Unique connection names must begin with the character ':' =
(ASCII=20
colon        character); bus names that are not unique names must not =
begin     =20
  with this character. (The bus must reject any attempt by an =
application       =20
to manually request a name beginning with ':'.) This restriction       =20
categorically prevents "spoofing"; messages sent to a unique name        =
will=20
always go to the expected connection.       </P>
<P>        When a connection is closed, all the names that it owns are =
deleted=20
(or        transferred to the next connection in the queue if any).      =
 </P>
<P>        A connection can request additional names to be associated =
with it=20
using        the <CODE =
class=3D"literal">org.freedesktop.DBus.RequestName</CODE>=20
message. <A title=3D"Bus names" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-bus">the=20
section called =93Bus names=94</A> describes the format of a valid       =
 name.=20
These names can be released again using the         <CODE=20
class=3D"literal">org.freedesktop.DBus.ReleaseName</CODE> message.       =
</P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-request-name"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.RequestName</CODE></H4></DIV></DIV=
></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            UINT32 RequestName (in STRING =
name, in UINT32 flags)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name to request</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>UINT32</TD>
    <TD>Flags</TD></TR></TBODY></TABLE></DIV>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>UINT32</TD>
    <TD>Return value</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This method call should be sent to           <CODE=20
class=3D"literal">org.freedesktop.DBus</CODE> and asks the message bus =
to         =20
assign the given name to the method caller. Each name maintains a        =
  queue=20
of possible owners, where the head of the queue is the primary          =
or=20
current owner of the name. Each potential owner in the queue          =
maintains=20
the DBUS_NAME_FLAG_ALLOW_REPLACEMENT and          =
DBUS_NAME_FLAG_DO_NOT_QUEUE=20
settings from its latest RequestName          call.  When RequestName is =
invoked=20
the following occurs:           </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>                If the method caller is currently the primary owner =
of the=20
  name,                the DBUS_NAME_FLAG_ALLOW_REPLACEMENT and=20
  DBUS_NAME_FLAG_DO_NOT_QUEUE                values are updated with the =
values=20
  from the new RequestName call,                 and nothing further =
happens.   =20
             </P></LI>
  <LI class=3D"listitem">
  <P>                If the current primary owner (head of the queue) =
has       =20
          DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, and the RequestName      =
       =20
    invocation has the DBUS_NAME_FLAG_REPLACE_EXISTING flag, then        =
       =20
  the caller of RequestName replaces the current primary owner at        =
       =20
  the head of the queue and the current primary owner moves to the       =
       =20
   second position in the queue. If the caller of RequestName was        =
       =20
   in the queue previously its flags are updated with the values from    =
       =20
       the new RequestName in addition to moving it to the head of the =
queue.   =20
             </P></LI>
  <LI class=3D"listitem">
  <P>                If replacement is not possible, and the method =
caller is   =20
              currently in the queue but not the primary owner, its =
flags are   =20
              updated with the values from the new RequestName call.     =
       =20
    </P></LI>
  <LI class=3D"listitem">
  <P>                If replacement is not possible, and the method =
caller is   =20
              currently not in the queue, the method caller is appended =
to the  =20
               queue.               </P></LI>
  <LI class=3D"listitem">
  <P>                If any connection in the queue has=20
  DBUS_NAME_FLAG_DO_NOT_QUEUE                set and is not the primary =
owner,=20
  it is removed from the                queue. This can apply to the =
previous=20
  primary owner (if it                was replaced) or the method caller =
(if it=20
  updated the                DBUS_NAME_FLAG_DO_NOT_QUEUE flag while =
still stuck=20
  in the                queue, or if it was just added to the queue with =
that=20
  flag set).               </P></LI></UL></DIV>
<P></P>
<P>          Note that DBUS_NAME_FLAG_REPLACE_EXISTING results in =
"jumping the  =20
       queue," even if another application already in the queue had =
specified   =20
      DBUS_NAME_FLAG_REPLACE_EXISTING.  This comes up if a primary owner =
       =20
 that does not allow replacement goes away, and the next primary owner   =
      =20
does allow replacement. In this case, queued items that specified        =
 =20
DBUS_NAME_FLAG_REPLACE_EXISTING <SPAN class=3D"emphasis"><EM>do =
not</EM></SPAN>   =20
      automatically replace the new primary owner. In other words,       =
  =20
DBUS_NAME_FLAG_REPLACE_EXISTING is not saved, it is only used at the     =
    =20
time RequestName is called. This is deliberate to avoid an infinite loop =
       =20
 anytime two applications are both DBUS_NAME_FLAG_ALLOW_REPLACEMENT      =
    =20
and DBUS_NAME_FLAG_REPLACE_EXISTING.         </P>
<P>          The flags argument contains any of the following values =
logically=20
ORed          together:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional Name</TH>
    <TH>Value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>DBUS_NAME_FLAG_ALLOW_REPLACEMENT</TD>
    <TD>0x1</TD>
    <TD>                    If an application A specifies this flag and=20
      succeeds in                    becoming the owner of the name, and =
another=20
      application B                    later calls RequestName with the  =
       =20
                DBUS_NAME_FLAG_REPLACE_EXISTING flag, then application A =
       =20
                 will lose ownership and receive a                     =
<CODE=20
      class=3D"literal">org.freedesktop.DBus.NameLost</CODE> signal, and =
         =20
               application B will become the new owner. If=20
      DBUS_NAME_FLAG_ALLOW_REPLACEMENT                    is not =
specified by=20
      application A, or DBUS_NAME_FLAG_REPLACE_EXISTING                  =
  is=20
      not specified by application B, then application B will not =
replace       =20
                  application A as the owner.                   =
</TD></TR>
  <TR>
    <TD>DBUS_NAME_FLAG_REPLACE_EXISTING</TD>
    <TD>0x2</TD>
    <TD>                    Try to replace the current owner if there is =
one.=20
      If this                    flag is not set the application will =
only=20
      become the owner of                    the name if there is no =
current=20
      owner. If this flag is set,                    the application =
will=20
      replace the current owner if                    the current owner=20
      specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT.                   =
</TD></TR>
  <TR>
    <TD>DBUS_NAME_FLAG_DO_NOT_QUEUE</TD>
    <TD>0x4</TD>
    <TD>                    Without this flag, if an application =
requests a=20
      name that is                    already owned, the application =
will be=20
      placed in a queue to                    own the name when the =
current=20
      owner gives it up. If this                    flag is given, the=20
      application will not be placed in the                    queue, =
the=20
      request for the name will simply fail.  This flag                  =
  also=20
      affects behavior when an application is replaced as                =
   =20
      name owner; by default the application moves back into the         =
       =20
         waiting queue, unless this flag was provided when the =
application      =20
                   became the name owner.                  =20
</TD></TR></TBODY></TABLE></DIV>
<P>          The return code can be one of the following values:         =
  </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional Name</TH>
    <TH>Value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER</TD>
    <TD>1</TD>
    <TD>The caller is now the primary owner of                  the =
name,=20
      replacing any previous owner. Either the name had no               =
  =20
      owner before, or the caller specified                 =20
      DBUS_NAME_FLAG_REPLACE_EXISTING and the current owner specified    =
       =20
            DBUS_NAME_FLAG_ALLOW_REPLACEMENT.</TD></TR>
  <TR>
    <TD>DBUS_REQUEST_NAME_REPLY_IN_QUEUE</TD>
    <TD>2</TD>
    <TD>The name already had an owner,                   =20
      DBUS_NAME_FLAG_DO_NOT_QUEUE was not specified, and either          =
       =20
        the current owner did not specify                   =20
      DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the requesting                 =
  =20
      application did not specify DBUS_NAME_FLAG_REPLACE_EXISTING.       =
       =20
            </TD></TR>
  <TR>
    <TD>DBUS_REQUEST_NAME_REPLY_EXISTS</TD>
    <TD>3</TD>
    <TD>The name already has an owner,                 =20
      DBUS_NAME_FLAG_DO_NOT_QUEUE was specified, and either              =
   =20
      DBUS_NAME_FLAG_ALLOW_REPLACEMENT was not specified by the          =
       =20
      current owner, or DBUS_NAME_FLAG_REPLACE_EXISTING was not          =
       =20
      specified by the requesting application.</TD></TR>
  <TR>
    <TD>DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER</TD>
    <TD>4</TD>
    <TD>The application trying to request ownership of a name is already =
the=20
      owner of it.</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-release-name"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.ReleaseName</CODE></H4></DIV></DIV=
></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            UINT32 ReleaseName (in STRING =
name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name to release</TD></TR></TBODY></TABLE></DIV>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>UINT32</TD>
    <TD>Return value</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This method call should be sent to           <CODE=20
class=3D"literal">org.freedesktop.DBus</CODE> and asks the message bus =
to         =20
release the method caller's claim to the given name. If the caller is    =
     =20
the primary owner, a new primary owner will be selected from the         =
 queue=20
if any other owners are waiting. If the caller is waiting in          =
the queue=20
for the name, the caller will removed from the queue and          will =
not be=20
made an owner of the name if it later becomes available.          If =
there are=20
no other owners in the queue for the name, it will be          removed =
from the=20
bus entirely.          The return code can be one of the following =
values:      =20
    </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Conventional Name</TH>
    <TH>Value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>DBUS_RELEASE_NAME_REPLY_RELEASED</TD>
    <TD>1</TD>
    <TD>The caller has released his claim on                  the given =
name.=20
      Either the caller was the primary owner of                  the =
name, and=20
      the name is now unused or taken by somebody                  =
waiting in=20
      the queue for the name, or the caller was waiting                  =
in the=20
      queue for the name and has now been removed from the               =
  =20
      queue.</TD></TR>
  <TR>
    <TD>DBUS_RELEASE_NAME_REPLY_NON_EXISTENT</TD>
    <TD>2</TD>
    <TD>The given name does not exist on this bus.</TD></TR>
  <TR>
    <TD>DBUS_RELEASE_NAME_REPLY_NOT_OWNER</TD>
    <TD>3</TD>
    <TD>The caller was not the primary owner of this name,               =
  =20
      and was also not waiting in the queue to own this=20
name.</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-list-queued-owners"></A><CODE =
class=3D"literal">org.freedesktop.DBus.ListQueuedOwners</CODE></H4></DIV>=
</DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            ARRAY of STRING =
ListQueuedOwners (in STRING name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>The well-known bus name to query, such as                     =
<CODE=20
      =
class=3D"literal">com.example.cappuccino</CODE></TD></TR></TBODY></TABLE>=
</DIV>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>ARRAY of STRING</TD>
    <TD>The unique bus names of connections currently queued             =
     =20
       for the name</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This method call should be sent to           <CODE=20
class=3D"literal">org.freedesktop.DBus</CODE> and lists the connections  =
       =20
currently queued for a bus name (see           <A title=3D"Queued Name =
Owner"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-queu=
ed-owner">Queued=20
Name Owner</A>).         </P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-bus-routing"></A>Message Bus =
Message=20
Routing</H3></DIV></DIV></DIV>
<P>        Messages may have a <CODE =
class=3D"literal">DESTINATION</CODE> field=20
(see <A title=3D"Header Fields" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-header-fields">the=20
section called =93Header Fields=94</A>), resulting in a         <EM =
class=3D"firstterm">unicast=20
message</EM>.  If the         <CODE class=3D"literal">DESTINATION</CODE> =
field is=20
present, it specifies a message        recipient by name. Method calls =
and=20
replies normally specify this field.        The message bus must send =
messages=20
(of any type) with the         <CODE =
class=3D"literal">DESTINATION</CODE> field=20
set to the specified recipient,        regardless of whether the =
recipient has=20
set up a match rule matching        the message.       </P>
<P>        When the message bus receives a signal, if the         <CODE =
class=3D"literal">DESTINATION</CODE>=20
field is absent, it is considered to        be a <EM =
class=3D"firstterm">broadcast=20
signal</EM>, and is sent to all        applications with <EM=20
class=3D"firstterm">message matching rules</EM> that        match the =
message.=20
Most signal messages are broadcasts.       </P>
<P>        Unicast signal messages (those with a <CODE=20
class=3D"literal">DESTINATION</CODE>        field) are not commonly =
used, but they=20
are treated like any unicast        message: they are delivered to the =
specified=20
receipient,        regardless of its match rules.  One use for unicast =
signals=20
is to        avoid a race condition in which a signal is emitted before =
the=20
intended        recipient can call <A =
title=3D"org.freedesktop.DBus.AddMatch"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#bus-messa=
ges-add-match">the=20
section called =93<CODE =
class=3D"literal">org.freedesktop.DBus.AddMatch</CODE>=94</A>=20
to        receive that signal: if the signal is sent directly to that =
recipient =20
      using a unicast message, it does not need to add a match rule at =
all,     =20
  and there is no race condition.  Another use for unicast signals,      =
  on=20
message buses whose security policy prevents eavesdropping, is to        =
send=20
sensitive information which should only be visible to one        =
recipient.     =20
 </P>
<P>        When the message bus receives a method call, if the         =
<CODE=20
class=3D"literal">DESTINATION</CODE> field is absent, the call is taken =
to be     =20
  a standard one-to-one message and interpreted by the message bus       =
=20
itself. For example, sending an         <CODE=20
class=3D"literal">org.freedesktop.DBus.Peer.Ping</CODE> message with no  =
      =20
<CODE class=3D"literal">DESTINATION</CODE> will cause the message bus =
itself to   =20
    reply to the ping immediately; the message bus will not make this    =
   =20
message visible to other applications.       </P>
<P>        Continuing the <CODE=20
class=3D"literal">org.freedesktop.DBus.Peer.Ping</CODE> example, if      =
  the=20
ping message were sent with a <CODE class=3D"literal">DESTINATION</CODE> =
name of  =20
      <CODE class=3D"literal">com.yoyodyne.Screensaver</CODE>, then the =
ping would=20
be        forwarded, and the Yoyodyne Corporation screensaver =
application would=20
be        expected to reply to the ping.       </P>
<P>        Message bus implementations may impose a security policy =
which       =20
prevents certain messages from being sent or received.        When a =
message=20
cannot be sent or received due to a security        policy, the message =
bus=20
should send an error reply, unless the        original message had the =
<CODE=20
class=3D"literal">NO_REPLY</CODE> flag.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A=20
name=3D"message-bus-routing-eavesdropping"></A>Eavesdropping</H4></DIV></=
DIV></DIV>
<P>          Receiving a unicast message whose <CODE=20
class=3D"literal">DESTINATION</CODE>          indicates a different =
recipient is=20
called           <EM class=3D"firstterm">eavesdropping</EM>. On a =
message bus=20
which acts as          a security boundary (like the standard system =
bus), the=20
security          policy should usually prevent eavesdropping, since =
unicast=20
messages          are normally kept private and may contain =
security-sensitive  =20
       information.         </P>
<P>          Eavesdropping is mainly useful for debugging tools, such as =
       =20
 the <CODE class=3D"literal">dbus-monitor</CODE> tool in the reference   =
      =20
implementation of D-Bus. Tools which eavesdrop on the message bus        =
 =20
should be careful to avoid sending a reply or error in response to       =
  =20
messages intended for a different client.         </P>
<P>          Clients may attempt to eavesdrop by adding match rules      =
   =20
(see <A title=3D"Match Rules" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing-match-rules">the=20
section called =93Match Rules=94</A>) containing          the <CODE=20
class=3D"literal">eavesdrop=3D'true'</CODE> match. If the message bus'   =
      =20
security policy does not allow eavesdropping, the match rule can         =
 still=20
be added, but will not have any practical effect. For          =
compatibility=20
with older message bus implementations, if adding such          a match =
rule=20
results in an error reply, the client may fall back to          adding =
the same=20
rule with the <CODE class=3D"literal">eavesdrop</CODE> match          =
omitted.    =20
    </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-bus-routing-match-rules"></A>Match=20
Rules</H4></DIV></DIV></DIV>
<P>          An important part of the message bus routing protocol is =
match     =20
    rules. Match rules describe the messages that should be sent to a    =
     =20
client, based on the contents of the message.  Broadcast signals         =
 are=20
only sent to clients which have a suitable match rule: this          =
avoids=20
waking up client processes to deal with signals that are          not =
relevant=20
to that client.         </P>
<P>          Messages that list a client as their <CODE=20
class=3D"literal">DESTINATION</CODE>          do not need to match the =
client's=20
match rules, and are sent to that          client regardless. As a =
result, match=20
rules are mainly used to          receive a subset of broadcast signals. =
       =20
</P>
<P>          Match rules can also be used for eavesdropping          =
(see <A=20
title=3D"Eavesdropping" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing-eavesdropping">the=20
section called =93Eavesdropping=94</A>),           if the security =
policy of the=20
message bus allows it.         </P>
<P>          Match rules are added using the AddMatch bus method         =
  (see=20
<A title=3D"org.freedesktop.DBus.AddMatch" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#bus-messa=
ges-add-match">the=20
section called =93<CODE=20
class=3D"literal">org.freedesktop.DBus.AddMatch</CODE>=94</A>).  Rules =
are         =20
specified as a string of comma separated key/value pairs.           =
Excluding a=20
key from the rule indicates a wildcard match.            For instance =
excluding=20
the the member from a match rule but           adding a sender would let =
all=20
messages from that sender through.          An example of a complete =
rule would=20
be          =20
"type=3D'signal',sender=3D'org.freedesktop.DBus',interface=3D'org.freedes=
ktop.DBus',member=3D'Foo',path=3D'/bar/foo',destination=3D':452345.34',ar=
g2=3D'bar'"=20
        </P>
<P>          The following table describes the keys that can be used to =
create  =20
        a match rule.           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Key</TH>
    <TH>Possible Values</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE class=3D"literal">type</CODE></TD>
    <TD>'signal', 'method_call', 'method_return', 'error'</TD>
    <TD>Match on the message type.  An example of a type match is=20
    type=3D'signal'</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">sender</CODE></TD>
    <TD>A bus or unique name (see <A title=3D"Bus Name" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-bus-=
name">Bus=20
      Name</A>                  and <A title=3D"Unique Connection Name" =
class=3D"xref"=20
      =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-uniq=
ue-name">Unique=20
      Connection Name</A> respectively)                   </TD>
    <TD>Match messages sent by a particular sender.  An example of a =
sender=20
      match                  is sender=3D'org.freedesktop.Hal'</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">interface</CODE></TD>
    <TD>An interface name (see <A title=3D"Interface names" =
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-interface">the=20
      section called =93Interface names=94</A>)</TD>
    <TD>Match messages sent over or to a particular interface.  An =
example of=20
      an                  interface match is=20
      interface=3D'org.freedesktop.Hal.Manager'.                  If a =
message=20
      omits the interface header, it must not match any rule             =
     =20
      that specifies this key.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">member</CODE></TD>
    <TD>Any valid method or signal name</TD>
    <TD>Matches messages which have the give method or signal name. An =
example=20
      of                  a member match is =
member=3D'NameOwnerChanged'</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">path</CODE></TD>
    <TD>An object path (see <A title=3D"Valid Object Paths" =
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-marshaling-object-path">the=20
      section called =93Valid Object Paths=94</A>)</TD>
    <TD>Matches messages which are sent from or to the given object. An=20
      example of a                  path match is=20
      path=3D'/org/freedesktop/Hal/Manager'</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">path_namespace</CODE></TD>
    <TD>An object path</TD>
    <TD>
      <P>                      Matches messages which are sent from or =
to an    =20
                       object for which the object path is either the    =
       =20
                given value, or that value followed by one or            =
       =20
        more path components.                     </P>
      <P>                      For example,                       <CODE =
class=3D"literal">path_namespace=3D'/com/example/foo'</CODE>=20
                           would match signals sent by                   =
   =20
      <CODE class=3D"literal">/com/example/foo</CODE>                    =
  or by  =20
                          <CODE =
class=3D"literal">/com/example/foo/bar</CODE>,    =20
                       but not by                       <CODE=20
      class=3D"literal">/com/example/foobar</CODE>.                     =
</P>
      <P>                      Using both <CODE =
class=3D"literal">path</CODE> and =20
                           <CODE class=3D"literal">path_namespace</CODE> =
in the=20
      same match                      rule is not allowed.               =
     =20
      </P>
      <P><SPAN class=3D"emphasis"><EM>                        This match =
key was=20
      added in version 0.16 of the                        D-Bus =
specification=20
      and implemented by the bus                        daemon in dbus =
1.5.0 and=20
      later.                       </EM></SPAN>                     =
</P></TD></TR>
  <TR>
    <TD><CODE class=3D"literal">destination</CODE></TD>
    <TD>A unique name (see <A title=3D"Unique Connection Name" =
class=3D"xref"=20
      =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-uniq=
ue-name">Unique=20
      Connection Name</A>)</TD>
    <TD>Matches messages which are being sent to the given unique name. =
An    =20
                   example of a destination match is =
destination=3D':1.0'</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">arg[0, 1, 2, 3, ...]</CODE></TD>
    <TD>Any string</TD>
    <TD>Arg matches are special and are used for further restricting the =
     =20
                  match based on the arguments in the body of a message. =
Only=20
      arguments of type                  STRING can be matched in this =
way. An=20
      example of an argument match                   would be =
arg3=3D'Foo'. Only=20
      argument indexes from 0 to 63 should be                   =
accepted.</TD></TR>
  <TR>
    <TD><CODE class=3D"literal">arg[0, 1, 2, 3, ...]path</CODE></TD>
    <TD>Any string</TD>
    <TD>
      <P>Argument path matches provide a specialised form of wildcard =
matching=20
      for                      path-like namespaces. They can match =
arguments=20
      whose type is either STRING or                      OBJECT_PATH. =
As with=20
      normal argument matches,                      if the argument is =
exactly=20
      equal to the string given in the match                      rule =
then the=20
      rule is satisfied. Additionally, there is also a                   =
  =20
      match when either the string given in the match rule or the        =
       =20
            appropriate message argument ends with '/' and is a prefix =
of the   =20
                        other. An example argument path match is=20
      arg0path=3D'/aa/bb/'. This                      would match =
messages with=20
      first arguments of '/', '/aa/',                      '/aa/bb/',=20
      '/aa/bb/cc/' and '/aa/bb/cc'. It would not match                   =
  =20
      messages with first arguments of '/aa/b', '/aa' or even =
'/aa/bb'.</P>
      <P>This is intended for monitoring =93directories=94 in file =
system-like      =20
                     hierarchies, as used in the <EM=20
      class=3D"citetitle">dconf</EM> configuration                      =
system. An=20
      application interested in all nodes in a particular hierarchy =
would       =20
                    monitor <CODE=20
      class=3D"literal">arg0path=3D'/ca/example/foo/'</CODE>. Then the =
service could=20
                           emit a signal with zeroth argument <CODE =
class=3D"literal">"/ca/example/foo/bar"</CODE>=20
      to                      represent a modification to the =93bar=94 =
property, or=20
      a signal with zeroth                      argument <CODE=20
      class=3D"literal">"/ca/example/"</CODE> to represent atomic =
modification of =20
                          many properties within that directory, and the =

      interested application would be                      notified in =
both=20
      cases.</P>
      <P><SPAN class=3D"emphasis"><EM>                        This match =
key was=20
      added in version 0.12 of the                        D-Bus =
specification,=20
      implemented for STRING                        arguments by the bus =
daemon=20
      in dbus 1.2.0 and later,                        and implemented =
for=20
      OBJECT_PATH arguments in dbus 1.5.0                        and =
later.     =20
                       </EM></SPAN>                     </P></TD></TR>
  <TR>
    <TD><CODE class=3D"literal">arg0namespace</CODE></TD>
    <TD>Like a bus name, except that the string is not                   =
=20
      required to contain a '.' (period)</TD>
    <TD>
      <P>Match messages whose first argument is of type STRING, and is a =
bus=20
      name                      or interface name within the specified=20
      namespace. This is primarily intended                      for =
watching=20
      name owner changes for a group of related bus names, rather than   =
       =20
                 for a single name or all name changes.</P>
      <P>Because every valid interface name is also a valid              =
       =20
      bus name, this can also be used for messages whose                 =
    =20
      first argument is an interface name.</P>
      <P>For example, the match rule                       <CODE=20
      =
class=3D"literal">member=3D'NameOwnerChanged',arg0namespace=3D'com.exampl=
e.backend'</CODE>=20
                           matches name owner changes for bus names such =
as     =20
                       <CODE =
class=3D"literal">com.example.backend.foo</CODE>,    =20
                        <CODE=20
      class=3D"literal">com.example.backend.foo.bar</CODE>, and          =
         =20
         <CODE class=3D"literal">com.example.backend</CODE> itself.</P>
      <P>See also <A title=3D"org.freedesktop.DBus.NameOwnerChanged" =
class=3D"xref"=20
      =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#bus-messa=
ges-name-owner-changed">the=20
      section called =93<CODE=20
      =
class=3D"literal">org.freedesktop.DBus.NameOwnerChanged</CODE>=94</A>.</P=
>
      <P><SPAN class=3D"emphasis"><EM>This match key was added in =
version 0.16 of=20
      the                        D-Bus specification and implemented by =
the bus =20
                            daemon in dbus 1.5.0 and later.              =
       =20
       </EM></SPAN>                     </P></TD></TR>
  <TR>
    <TD><CODE class=3D"literal">eavesdrop</CODE></TD>
    <TD><CODE class=3D"literal">'true'</CODE>, <CODE=20
      class=3D"literal">'false'</CODE></TD>
    <TD>Since D-Bus 1.5.6, match rules do not                    match=20
      messages which have a <CODE class=3D"literal">DESTINATION</CODE>   =
         =20
             field unless the match rule specifically                    =

      requests this                    (see <A title=3D"Eavesdropping" =
class=3D"xref"=20
      =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing-eavesdropping">the=20
      section called =93Eavesdropping=94</A>)                     by =
specifying=20
      <CODE class=3D"literal">eavesdrop=3D'true'</CODE>                  =
  in the=20
      match rule.  <CODE class=3D"literal">eavesdrop=3D'false'</CODE>    =
           =20
          restores the default behaviour. Messages are                   =
=20
      delivered to their <CODE class=3D"literal">DESTINATION</CODE>      =
         =20
          regardless of match rules, so this match does not              =
     =20
      affect normal delivery of unicast messages.                    If =
the=20
      message bus has a security policy which forbids                    =

      eavesdropping, this match may still be used without error,         =
       =20
         but will not have any practical effect.                    In =
older=20
      versions of D-Bus, this match was not allowed                    =
in match=20
      rules, and all match rules behaved as if                     <CODE =
class=3D"literal">eavesdrop=3D'true'</CODE>=20
      had been used.                   </TD></TR></TBODY></TABLE></DIV>
<P></P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A =
name=3D"message-bus-starting-services"></A>Message Bus=20
Starting Services</H3></DIV></DIV></DIV>
<P>        The message bus can start applications on behalf of other=20
applications.        In CORBA terms, this would be called <EM=20
class=3D"firstterm">activation</EM>.        An application that can be =
started in=20
this way is called a         <EM class=3D"firstterm">service</EM>.       =
</P>
<P>        With D-Bus, starting a service is normally done by name. That =
is,    =20
   applications ask the message bus to start some program that will own =
a       =20
well-known name, such as <CODE =
class=3D"literal">com.example.TextEditor</CODE>.   =20
    This implies a contract documented along with the name         <CODE =
class=3D"literal">com.example.TextEditor</CODE>=20
for which object        the owner of that name will provide, and what =
interfaces=20
those         objects will have.       </P>
<P>        To find an executable corresponding to a particular name, the =
bus=20
daemon        looks for <EM class=3D"firstterm">service description =
files</EM>. =20
Service        description files define a mapping from names to =
executables.=20
Different        kinds of message bus will look for these files in =
different=20
places, see         <A title=3D"Well-known Message Bus Instances" =
class=3D"xref"=20
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-types">the=20
section called =93Well-known Message Bus Instances=94</A>.       </P>
<P>Service description files have the ".service" file        extension. =
The=20
message bus will only load service description files        ending with=20
.service; all other files will be ignored.  The file format        is =
similar to=20
that of <A class=3D"ulink" =
href=3D"http://standards.freedesktop.org/desktop-entry-spec/desktop-entry=
-spec-latest.html"=20
target=3D"_top">desktop        entries</A>. All service description =
files must be=20
in UTF-8        encoding. To ensure that there will be no name =
collisions,=20
service files        must be namespaced using the same mechanism as =
messages and=20
service        names.       </P>
<P>        On the well-known system bus, the name of a service =
description file =20
      must be its well-known name plus <CODE =
class=3D"literal">.service</CODE>,   =20
    for instance         <CODE=20
class=3D"literal">com.example.ConfigurationDatabase.service</CODE>.      =
 </P>
<P>        On the well-known session bus, services should follow the =
same       =20
service description file naming convention as on the system bus,        =
but for=20
backwards compatibility they are not required to do so.       </P>
<P>        [FIXME the file format should be much better specified than =
"similar=20
to        .desktop entries" esp. since desktop entries are already       =
=20
badly-specified. ;-)]        These sections from the specification apply =
to=20
service files as well:         </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>General syntax</P></LI>
  <LI class=3D"listitem">
  <P>Comment format</P></LI></UL></DIV>
<P>        Service description files must contain a         <CODE =
class=3D"literal">D-BUS=20
Service</CODE> group with at least the keys         <CODE=20
class=3D"literal">Name</CODE> (the well-known name of the service)       =
 and=20
<CODE class=3D"literal">Exec</CODE> (the command to be executed).        =
 </P>
<DIV class=3D"figure"><A name=3D"idp56532816"></A>
<P class=3D"title"><B>Figure&nbsp;9.&nbsp;Example service description =
file</B></P>
<DIV class=3D"figure-contents">
<PRE class=3D"programlisting">            # Sample service description =
file=0A=
            [D-BUS Service]=0A=
            Name=3Dcom.example.ConfigurationDatabase=0A=
            Exec=3D/usr/bin/sample-configd=0A=
          </PRE></DIV></DIV>
<P><BR class=3D"figure-break"></P>
<P>        Additionally, service description files for the well-known =
system    =20
   bus on Unix must contain a <CODE class=3D"literal">User</CODE> key, =
whose value=20
       is the name of a user account (e.g. <CODE =
class=3D"literal">root</CODE>).  =20
     The system service will be run as that user.       </P>
<P>        When an application asks to start a service by name, the bus =
daemon=20
tries to        find a service that will own that name. It then tries to =
spawn=20
the        executable associated with it. If this fails, it will report =
an      =20
 error.       </P>
<P>        On the well-known system bus, it is not possible for two =
.service=20
files        in the same directory to offer the same service, because =
they are  =20
     constrained to have names that match the service name.       </P>
<P>        On the well-known session bus, if two .service files in the =
same     =20
  directory offer the same service name, the result is undefined.        =

Distributors should avoid this situation, for instance by naming        =
session=20
services' .service files according to their service name.       </P>
<P>        If two .service files in different directories offer the same =
      =20
service name, the one in the higher-priority directory is used:        =
for=20
instance, on the system bus, .service files in       =20
/usr/local/share/dbus-1/system-services take precedence over those       =
 in=20
/usr/share/dbus-1/system-services.       </P>
<P>        The executable launched will have the environment variable    =
    =20
<CODE class=3D"literal">DBUS_STARTER_ADDRESS</CODE> set to the address =
of the     =20
  message bus so it can connect and request the appropriate names.       =
</P>
<P>        The executable being launched may want to know whether the =
message=20
bus        starting it is one of the well-known message buses (see <A =
title=3D"Well-known Message Bus Instances"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-types">the=20
section called =93Well-known Message Bus Instances=94</A>). To =
facilitate this, the=20
bus must also set        the <CODE =
class=3D"literal">DBUS_STARTER_BUS_TYPE</CODE>=20
environment variable if it is one        of the well-known buses. The=20
currently-defined values for this variable        are <CODE=20
class=3D"literal">system</CODE> for the systemwide message bus,        =
and <CODE=20
class=3D"literal">session</CODE> for the per-login-session message       =
 bus. The=20
new executable must still connect to the address given        in <CODE =
class=3D"literal">DBUS_STARTER_ADDRESS</CODE>,=20
but may assume that the        resulting connection is to the well-known =
bus.   =20
   </P>
<P>        [FIXME there should be a timeout somewhere, either specified  =
     =20
in the .service file, by the client, or just a global value        and =
if the=20
client being activated fails to connect within that        timeout, an =
error=20
should be sent back.]       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"message-bus-starting-services-scope"></A>Message Bus=20
Service Scope</H4></DIV></DIV></DIV>
<P>          The "scope" of a service is its "per-", such as =
per-session,       =20
  per-machine, per-home-directory, or per-display. The reference         =
=20
implementation doesn't yet support starting services in a different      =
   =20
scope from the message bus itself. So e.g. if you start a service        =
  on=20
the session bus its scope is per-session.         </P>
<P>          We could add an optional scope to a bus name. For example, =
for     =20
    per-(display,session pair), we could have a unique ID for each =
display      =20
   generated automatically at login and set on screen 0 by executing a   =
      =20
special "set display ID" binary. The ID would be stored in a           =
<CODE=20
class=3D"literal">_DBUS_DISPLAY_ID</CODE> property and would be a string =
of       =20
  random bytes. This ID would then be used to scope names.         =20
Starting/locating a service could be done by ID-name pair rather than    =
     =20
only by name.         </P>
<P>          Contrast this with a per-display scope. To achieve that, we =
would  =20
        want a single bus spanning all sessions using a given display.   =
      =20
So we might set a <CODE =
class=3D"literal">_DBUS_DISPLAY_BUS_ADDRESS</CODE>        =20
  property on screen 0 of the display, pointing to this bus.        =20
</P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-bus-types"></A>Well-known Message =
Bus=20
Instances</H3></DIV></DIV></DIV>
<P>        Two standard message bus instances are defined here, along =
with how  =20
      to locate them and where their service files live.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-bus-types-login"></A>Login =
session message=20
bus</H4></DIV></DIV></DIV>
<P>          Each time a user logs in, a <EM class=3D"firstterm">login =
session=20
message            bus</EM> may be started. All applications in the =
user's login=20
         session may interact with one another using this message bus.   =
     =20
</P>
<P>          The address of the login session message bus is given       =
    in=20
the <CODE class=3D"literal">DBUS_SESSION_BUS_ADDRESS</CODE> environment  =
        =20
variable. If that variable is not set, applications may           also =
try to=20
read the address from the X Window System root           window property =
<CODE=20
class=3D"literal">_DBUS_SESSION_BUS_ADDRESS</CODE>.          The root =
window=20
property must have type <CODE class=3D"literal">STRING</CODE>.          =
The=20
environment variable should have precedence over the           root =
window=20
property.         </P>
<P>The address of the login session message bus is given in the         =
<CODE=20
class=3D"literal">DBUS_SESSION_BUS_ADDRESS</CODE> environment variable. =
If       =20
DBUS_SESSION_BUS_ADDRESS is not set, or if it's set to the string        =

"autolaunch:", the system should use platform-specific methods of        =

locating a running D-Bus session server, or starting one if a running    =
   =20
instance cannot be found. Note that this mechanism is not recommended    =
    for=20
attempting to determine if a daemon is running. It is inherently        =
racy to=20
attempt to make this determination, since the bus daemon may        be =
started=20
just before or just after the determination is made.        Therefore, =
it is=20
recommended that applications do not try to make this        =
determination for=20
their functionality purposes, and instead they        should attempt to =
start=20
the server.</P>
<DIV class=3D"sect4">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H5 class=3D"title"><A name=3D"message-bus-types-login-x-windows"></A>X =
Windowing=20
System</H5></DIV></DIV></DIV>
<P>            For the X Windowing System, the application must locate =
the      =20
     window owner of the selection represented by the atom formed by     =
      =20
concatenating:             </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>the literal string "_DBUS_SESSION_BUS_SELECTION_"</P></LI>
  <LI class=3D"listitem">
  <P>the current user's username</P></LI>
  <LI class=3D"listitem">
  <P>the literal character '_' (underscore)</P></LI>
  <LI class=3D"listitem">
  <P>the machine's ID</P></LI></UL></DIV>
<P></P>
<P>            The following properties are defined for the window that =
owns    =20
       this X selection:             </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <TBODY>
  <TR>
    <TD>
      <P>Atom</P></TD>
    <TD>
      <P>meaning</P></TD></TR>
  <TR>
    <TD>
      <P>_DBUS_SESSION_BUS_ADDRESS</P></TD>
    <TD>
      <P>the actual address of the server socket</P></TD></TR>
  <TR>
    <TD>
      <P>_DBUS_SESSION_BUS_PID</P></TD>
    <TD>
      <P>the PID of the server =
process</P></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>            At least the _DBUS_SESSION_BUS_ADDRESS property MUST be   =
       =20
 present in this window.           </P>
<P>            If the X selection cannot be located or if reading the    =
       =20
properties from the window fails, the implementation MUST conclude       =
    =20
that there is no D-Bus server running and proceed to start a new         =
  =20
server. (See below on concurrency issues)           </P>
<P>            Failure to connect to the D-Bus server address thus =
obtained     =20
      MUST be treated as a fatal connection error and should be reported =
       =20
   to the application.           </P>
<P>            As an alternative, an implementation MAY find the =
information    =20
       in the following file located in the current user's home =
directory,      =20
     in subdirectory .dbus/session-bus/:             </P>
<DIV class=3D"itemizedlist">
<UL class=3D"itemizedlist" style=3D"list-style-type: disc;">
  <LI class=3D"listitem">
  <P>the machine's ID</P></LI>
  <LI class=3D"listitem">
  <P>the literal character '-' (dash)</P></LI>
  <LI class=3D"listitem">
  <P>the X display without the screen number, with the                =
following=20
  prefixes removed, if present: ":", "localhost:"               =20
  ."localhost.localdomain:". That is, a display of               =20
  "localhost:10.0" produces just the number "10"</P></LI></UL></DIV>
<P></P>
<P>            The contents of this file NAME=3Dvalue assignment pairs =
and        =20
   lines starting with # are comments (no comments are allowed           =
=20
otherwise). The following variable names are defined:             </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL></COLGROUP>
  <TBODY>
  <TR>
    <TD>
      <P>Variable</P></TD>
    <TD>
      <P>meaning</P></TD></TR>
  <TR>
    <TD>
      <P>DBUS_SESSION_BUS_ADDRESS</P></TD>
    <TD>
      <P>the actual address of the server socket</P></TD></TR>
  <TR>
    <TD>
      <P>DBUS_SESSION_BUS_PID</P></TD>
    <TD>
      <P>the PID of the server process</P></TD></TR>
  <TR>
    <TD>
      <P>DBUS_SESSION_BUS_WINDOWID</P></TD>
    <TD>
      <P>the window ID</P></TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>            At least the DBUS_SESSION_BUS_ADDRESS variable MUST be =
present   =20
        in this file.           </P>
<P>            Failure to open this file MUST be interpreted as absence =
of a    =20
       running server. Therefore, the implementation MUST proceed to     =
      =20
attempting to launch a new bus server if the file cannot be            =
opened.  =20
        </P>
<P>            However, success in opening this file MUST NOT lead to =
the       =20
    conclusion that the server is running. Thus, a failure to connect to =
       =20
   the bus address obtained by the alternative method MUST NOT be        =
   =20
considered a fatal error. If the connection cannot be established,       =
    =20
the implementation MUST proceed to check the X selection settings or     =
      =20
to start the server on its own.           </P>
<P>            If the implementation concludes that the D-Bus server is =
not     =20
      running it MUST attempt to start a new server and it MUST also     =
      =20
ensure that the daemon started as an effect of the "autolaunch"          =
 =20
mechanism provides the lookup mechanisms described above, so           =20
subsequent calls can locate the newly started server. The           =20
implementation MUST also ensure that if two or more concurrent           =
=20
initiations happen, only one server remains running and all other        =
   =20
initiations are able to obtain the address of this server and            =
connect=20
to it. In other words, the implementation MUST ensure that            =
the X=20
selection is not present when it attempts to set it, without            =
allowing=20
another process to set the selection between the            verification =
and the=20
setting (e.g., by using XGrabServer /            XungrabServer).         =
 =20
</P></DIV>
<DIV class=3D"sect4">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H5 class=3D"title"><A name=3D"idp56589424"></A></H5></DIV></DIV></DIV>
<P>            On Unix systems, the session bus should search for =
.service files=20
           in <CODE =
class=3D"literal">$XDG_DATA_DIRS/dbus-1/services</CODE> as=20
defined            by the             <A class=3D"ulink" =
href=3D"http://standards.freedesktop.org/basedir-spec/basedir-spec-latest=
.html"=20
target=3D"_top">XDG Base Directory Specification</A>.            =
Implementations=20
may also search additional locations, which            should be =
searched with=20
lower priority than anything in            XDG_DATA_HOME, XDG_DATA_DIRS =
or their=20
respective defaults;            for example, the reference =
implementation also  =20
         looks in <CODE =
class=3D"literal">${datadir}/dbus-1/services</CODE> as    =20
       set at compile time.           </P>
<P>            As described in the XDG Base Directory Specification, =
software   =20
        packages should install their session .service files to their    =
       =20
configured <CODE class=3D"literal">${datadir}/dbus-1/services</CODE>,    =
       =20
where <CODE class=3D"literal">${datadir}</CODE> is as defined by the GNU =
         =20
 coding standards. System administrators or users can arrange            =
for=20
these service files to be read by setting XDG_DATA_DIRS or by            =

symlinking them into the default locations.           </P></DIV></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"message-bus-types-system"></A>System =
message=20
bus</H4></DIV></DIV></DIV>
<P>          A computer may have a <EM class=3D"firstterm">system =
message=20
bus</EM>,          accessible to all applications on the system. This =
message=20
bus may be          used to broadcast system events, such as adding new =
hardware=20
devices,           changes in the printer queue, and so forth.         =
</P>
<P>          The address of the system message bus is given           in =
the=20
<CODE class=3D"literal">DBUS_SYSTEM_BUS_ADDRESS</CODE> environment       =
   =20
variable. If that variable is not set, applications should try           =
to=20
connect to the well-known address           <CODE=20
class=3D"literal">unix:path=3D/var/run/dbus/system_bus_socket</CODE>.    =
       <A=20
name=3D"idp56598672" class=3D"footnote" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#ftn.idp56=
598672"><SUP=20
class=3D"footnote">[2]</SUP></A>         </P>
<P>          On Unix systems, the system bus should default to searching =
       =20
 for .service files in           <CODE=20
class=3D"literal">/usr/local/share/dbus-1/system-services</CODE>,        =
   <CODE=20
class=3D"literal">/usr/share/dbus-1/system-services</CODE> and           =
<CODE=20
class=3D"literal">/lib/dbus-1/system-services</CODE>, with that order    =
      of=20
precedence. It may also search other implementation-specific          =
locations,=20
but should not vary these locations based on environment          =
variables.    =20
      <A name=3D"idp56602880" class=3D"footnote" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#ftn.idp56=
602880"><SUP=20
class=3D"footnote">[3]</SUP></A>         </P>
<P>          Software packages should install their system .service      =
   =20
files to their configured           <CODE=20
class=3D"literal">${datadir}/dbus-1/system-services</CODE>,          =
where <CODE=20
class=3D"literal">${datadir}</CODE> is as defined by the GNU          =
coding=20
standards. System administrators can arrange          for these service =
files to=20
be read by editing the system bus'          configuration file or by =
symlinking=20
them into the default          locations.         </P></DIV></DIV>
<DIV class=3D"sect2">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H3 class=3D"title"><A name=3D"message-bus-messages"></A>Message Bus=20
Messages</H3></DIV></DIV></DIV>
<P>        The special message bus name <CODE=20
class=3D"literal">org.freedesktop.DBus</CODE>        responds to a =
number of=20
additional messages.       </P>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-hello"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.Hello</CODE></H4></DIV></DIV></DIV=
>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            STRING Hello ()=0A=
          </PRE>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique name assigned to the =
connection</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          Before an application is able to send messages to other=20
applications          it must send the <CODE=20
class=3D"literal">org.freedesktop.DBus.Hello</CODE> message          to =
the=20
message bus to obtain a unique name. If an application without          =
a unique=20
name tries to send a message to another application, or a          =
message to=20
the message bus itself that isn't the           <CODE=20
class=3D"literal">org.freedesktop.DBus.Hello</CODE> message, it will be  =
       =20
disconnected from the bus.         </P>
<P>          There is no corresponding "disconnect" request; if a client =
wishes=20
to          disconnect from the bus, it simply closes the socket (or =
other      =20
    communication channel).         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-list-names"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.ListNames</CODE></H4></DIV></DIV><=
/DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            ARRAY of STRING ListNames ()=0A=
          </PRE>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>ARRAY of STRING</TD>
    <TD>Array of strings where each string is a bus=20
name</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          Returns a list of all currently-owned names on the bus.     =
   =20
</P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-list-activatable-names"></A><CODE =
class=3D"literal">org.freedesktop.DBus.ListActivatableNames</CODE></H4></=
DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            ARRAY of STRING =
ListActivatableNames ()=0A=
          </PRE>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>ARRAY of STRING</TD>
    <TD>Array of strings where each string is a bus=20
name</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          Returns a list of all names that can be activated on the =
bus.      =20
  </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-name-exists"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.NameHasOwner</CODE></H4></DIV></DI=
V></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            BOOLEAN NameHasOwner (in =
STRING name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name to check</TD></TR></TBODY></TABLE></DIV>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>BOOLEAN</TD>
    <TD>Return value, true if the name =
exists</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          Checks if the specified name exists (currently has an =
owner).      =20
  </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-name-owner-changed"></A><CODE =
class=3D"literal">org.freedesktop.DBus.NameOwnerChanged</CODE></H4></DIV>=
</DIV></DIV>
<P>          This is a signal:           </P>
<PRE class=3D"programlisting">            NameOwnerChanged (STRING name, =
STRING old_owner, STRING new_owner)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name with a new owner</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>STRING</TD>
    <TD>Old owner or empty string if none</TD></TR>
  <TR>
    <TD>2</TD>
    <TD>STRING</TD>
    <TD>New owner or empty string if =
none</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This signal indicates that the owner of a name has changed. =
       =20
 It's also the signal to use to detect the appearance of           new =
names on=20
the bus.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-name-lost"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.NameLost</CODE></H4></DIV></DIV></=
DIV>
<P>          This is a signal:           </P>
<PRE class=3D"programlisting">            NameLost (STRING name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name which was lost</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This signal is sent to a specific application when it loses =
       =20
 ownership of a name.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-name-acquired"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.NameAcquired</CODE></H4></DIV></DI=
V></DIV>
<P>          This is a signal:           </P>
<PRE class=3D"programlisting">            NameAcquired (STRING name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name which was acquired</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This signal is sent to a specific application when it gains =
       =20
 ownership of a name.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-start-service-by-name"></A><CODE =
class=3D"literal">org.freedesktop.DBus.StartServiceByName</CODE></H4></DI=
V></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            UINT32 StartServiceByName (in =
STRING name, in UINT32 flags)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name of the service to start</TD></TR>
  <TR>
    <TD>1</TD>
    <TD>UINT32</TD>
    <TD>Flags (currently not used)</TD></TR></TBODY></TABLE></DIV>
<P>        Reply arguments:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>UINT32</TD>
    <TD>Return value</TD></TR></TBODY></TABLE></DIV>
<P>          Tries to launch the executable associated with a name. For =
more=20
information, see <A title=3D"Message Bus Starting Services" =
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-starting-services">the=20
section called =93Message Bus Starting Services=94</A>.         </P>
<P>The return value can be one of the following values:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Identifier</TH>
    <TH>Value</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>DBUS_START_REPLY_SUCCESS</TD>
    <TD>1</TD>
    <TD>The service was successfully started.</TD></TR>
  <TR>
    <TD>DBUS_START_REPLY_ALREADY_RUNNING</TD>
    <TD>2</TD>
    <TD>A connection already owns the given =
name.</TD></TR></TBODY></TABLE></DIV>
<P></P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-update-activation-environment"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.UpdateActivationEnvironment</CODE>=
</H4></DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            UpdateActivationEnvironment =
(in ARRAY of DICT&lt;STRING,STRING&gt; environment)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>ARRAY of DICT&lt;STRING,STRING&gt;</TD>
    <TD>Environment to add or update</TD></TR></TBODY></TABLE></DIV>
<P>            Normally, session bus activated services inherit the =
environment=20
of the bus daemon.  This method adds to or modifies that environment =
when=20
activating services.         </P>
<P>          Some bus instances, such as the standard system bus, may =
disable=20
access to this method for some or all callers.         </P>
<P>          Note, both the environment variable names and values must =
be valid=20
UTF-8.  There's no way to update the activation environment with data =
that is=20
invalid UTF-8.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-get-name-owner"></A><CODE =
class=3D"literal">org.freedesktop.DBus.GetNameOwner</CODE></H4></DIV></DI=
V></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            STRING GetNameOwner (in STRING =
name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Name to get the owner of</TD></TR></TBODY></TABLE></DIV>
<P>        Reply arguments:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Return value, a unique connection =
name</TD></TR></TBODY></TABLE></DIV>
<P>        Returns the unique connection name of the primary owner of =
the name  =20
     given. If the requested name doesn't have an owner, returns a       =
  <CODE=20
class=3D"literal">org.freedesktop.DBus.Error.NameHasNoOwner</CODE> =
error.       =20
</P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-get-connection-unix-user"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.GetConnectionUnixUser</CODE></H4><=
/DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            UINT32 GetConnectionUnixUser =
(in STRING bus_name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique or well-known bus name of the connection to               =
    =20
      query, such as <CODE class=3D"literal">:12.34</CODE> or            =
        =20
      <CODE =
class=3D"literal">com.example.tea</CODE></TD></TR></TBODY></TABLE></DIV>
<P>        Reply arguments:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>UINT32</TD>
    <TD>Unix user ID</TD></TR></TBODY></TABLE></DIV>
<P>        Returns the Unix user ID of the process connected to the =
server. If  =20
     unable to determine it (for instance, because the process is not on =
the    =20
   same machine as the bus daemon), an error is returned.        =
</P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A=20
name=3D"bus-messages-get-connection-unix-process-id"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.GetConnectionUnixProcessID</CODE><=
/H4></DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            UINT32 =
GetConnectionUnixProcessID (in STRING bus_name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique or well-known bus name of the connection to               =
    =20
      query, such as <CODE class=3D"literal">:12.34</CODE> or            =
        =20
      <CODE =
class=3D"literal">com.example.tea</CODE></TD></TR></TBODY></TABLE></DIV>
<P>        Reply arguments:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>UINT32</TD>
    <TD>Unix process id</TD></TR></TBODY></TABLE></DIV>
<P>        Returns the Unix process ID of the process connected to the =
server.=20
If        unable to determine it (for instance, because the process is =
not on=20
the        same machine as the bus daemon), an error is returned.        =

</P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-get-connection-credentials"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.GetConnectionCredentials</CODE></H=
4></DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            DICT&lt;STRING,VARIANT&gt; =
GetConnectionCredentials (in STRING bus_name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique or well-known bus name of the connection to               =
    =20
      query, such as <CODE class=3D"literal">:12.34</CODE> or            =
        =20
      <CODE =
class=3D"literal">com.example.tea</CODE></TD></TR></TBODY></TABLE></DIV>
<P>        Reply arguments:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>DICT&lt;STRING,VARIANT&gt;</TD>
    <TD>Credentials</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>        Returns as many credentials as possible for the process =
connected to =20
      the server. If unable to determine certain credentials (for =
instance,     =20
  because the process is not on the same machine as the bus daemon,      =
  or=20
because this version of the bus daemon does not support a        =
particular=20
security framework), or if the values of those credentials        cannot =
be=20
represented as documented here, then those credentials        are =
omitted.      =20
</P>
<P>        Keys in the returned dictionary not containing "." are =
defined       =20
by this specification. Bus daemon implementors supporting        =
credentials=20
frameworks not mentioned in this document should either        =
contribute=20
patches to this specification, or use keys containing        "." and =
starting=20
with a reversed domain name.         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Key</TH>
    <TH>Value type</TH>
    <TH>Value</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>UnixUserID</TD>
    <TD>UINT32</TD>
    <TD>The numeric Unix user ID, as defined by POSIX</TD></TR>
  <TR>
    <TD>ProcessID</TD>
    <TD>UINT32</TD>
    <TD>The numeric process ID, on platforms that have                  =
this=20
      concept. On Unix, this is the process ID defined by                =
 =20
    POSIX.</TD></TR></TBODY></TABLE></DIV>
<P></P>
<P>          This method was added in D-Bus 1.7 to reduce the =
round-trips       =20
  required to list a process's credentials. In older versions, calling   =
      =20
this method will fail: applications should recover by using the          =

separate methods such as           <A =
title=3D"org.freedesktop.DBus.GetConnectionUnixUser"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#bus-messa=
ges-get-connection-unix-user">the=20
section called =93<CODE=20
class=3D"literal">org.freedesktop.DBus.GetConnectionUnixUser</CODE>=94</A=
>          =20
instead.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A =
name=3D"bus-messages-get-adt-audit-session-data"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.GetAdtAuditSessionData</CODE></H4>=
</DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            ARRAY of BYTE =
GetAdtAuditSessionData (in STRING bus_name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique or well-known bus name of the connection to               =
    =20
      query, such as <CODE class=3D"literal">:12.34</CODE> or            =
        =20
      <CODE =
class=3D"literal">com.example.tea</CODE></TD></TR></TBODY></TABLE></DIV>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>ARRAY of BYTE</TD>
    <TD>auditing data as returned by                   =20
      adt_export_session_data()</TD></TR></TBODY></TABLE></DIV>
<P>          Returns auditing data used by Solaris ADT, in an =
unspecified       =20
  binary format. If you know what this means, please contribute          =

documentation via the D-Bus bug tracking system.          This method is =
on the=20
core DBus interface for historical reasons;          the same =
information should=20
be made available via           <A =
title=3D"org.freedesktop.DBus.GetConnectionCredentials"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#bus-messa=
ges-get-connection-credentials">the=20
section called =93<CODE=20
class=3D"literal">org.freedesktop.DBus.GetConnectionCredentials</CODE>=94=
</A>       =20
   in future.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A=20
name=3D"bus-messages-get-connection-selinux-security-context"></A><CODE =
class=3D"literal">org.freedesktop.DBus.GetConnectionSELinuxSecurityContex=
t</CODE></H4></DIV></DIV></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            ARRAY of BYTE =
GetConnectionSELinuxSecurityContext (in STRING bus_name)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique or well-known bus name of the connection to               =
    =20
      query, such as <CODE class=3D"literal">:12.34</CODE> or            =
        =20
      <CODE =
class=3D"literal">com.example.tea</CODE></TD></TR></TBODY></TABLE></DIV>
<P>          Reply arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>ARRAY of BYTE</TD>
    <TD>some sort of string of bytes, not necessarily UTF-8,             =
     =20
       not including '\0'</TD></TR></TBODY></TABLE></DIV>
<P>          Returns the security context used by SELinux, in an =
unspecified    =20
     format. If you know what this means, please contribute         =20
documentation via the D-Bus bug tracking system.          This method is =
on the=20
core DBus interface for historical reasons;          the same =
information should=20
be made available via           <A =
title=3D"org.freedesktop.DBus.GetConnectionCredentials"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#bus-messa=
ges-get-connection-credentials">the=20
section called =93<CODE=20
class=3D"literal">org.freedesktop.DBus.GetConnectionCredentials</CODE>=94=
</A>       =20
   in future.         </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-add-match"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.AddMatch</CODE></H4></DIV></DIV></=
DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            AddMatch (in STRING rule)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Match rule to add to the =
connection</TD></TR></TBODY></TABLE></DIV>
<P>        Adds a match rule to match messages going through the message =
bus=20
(see <A title=3D"Match Rules" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing-match-rules">the=20
section called =93Match Rules=94</A>).          If the bus does not have =
enough=20
resources the <CODE =
class=3D"literal">org.freedesktop.DBus.Error.OOM</CODE>       =20
error is returned.        </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-remove-match"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.RemoveMatch</CODE></H4></DIV></DIV=
></DIV>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            RemoveMatch (in STRING rule)=0A=
          </PRE>
<P>          Message arguments:           </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Match rule to remove from the =
connection</TD></TR></TBODY></TABLE></DIV>
<P>        Removes the first rule that matches (see <A title=3D"Match =
Rules"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-b=
us-routing-match-rules">the=20
section called =93Match Rules=94</A>).          If the rule is not found =
the <CODE=20
class=3D"literal">org.freedesktop.DBus.Error.MatchRuleNotFound</CODE>    =
    error=20
is returned.        </P></DIV>
<DIV class=3D"sect3">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H4 class=3D"title"><A name=3D"bus-messages-get-id"></A><CODE=20
class=3D"literal">org.freedesktop.DBus.GetId</CODE></H4></DIV></DIV></DIV=
>
<P>          As a method:           </P>
<PRE class=3D"programlisting">            GetId (out STRING id)=0A=
          </PRE>
<P>        Reply arguments:         </P>
<DIV class=3D"informaltable">
<TABLE border=3D"1">
  <COLGROUP>
  <COL>
  <COL>
  <COL></COLGROUP>
  <THEAD>
  <TR>
    <TH>Argument</TH>
    <TH>Type</TH>
    <TH>Description</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>0</TD>
    <TD>STRING</TD>
    <TD>Unique ID identifying the bus =
daemon</TD></TR></TBODY></TABLE></DIV>
<P>        Gets the unique ID of the bus. The unique ID here is shared =
among all=20
addresses the         bus daemon is listening on (TCP, UNIX domain =
socket, etc.)=20
and its format is described in          <A title=3D"UUIDs" =
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#uuids">th=
e=20
section called =93UUIDs=94</A>. Each address the bus is listening on =
also has its=20
own unique         ID, as described in <A title=3D"Server Addresses" =
class=3D"xref"=20
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#addresses=
">the=20
section called =93Server Addresses=94</A>. The per-bus and per-address =
IDs are not=20
related.        There is also a per-machine ID, described in <A =
title=3D"org.freedesktop.DBus.Peer"=20
class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#standard-=
interfaces-peer">the=20
section called =93<CODE =
class=3D"literal">org.freedesktop.DBus.Peer</CODE>=94</A> and=20
returned        by org.freedesktop.DBus.Peer.GetMachineId().        For =
a=20
desktop session bus, the bus ID can be used as a way to uniquely =
identify a=20
user's session.         </P></DIV></DIV></DIV>
<DIV class=3D"glossary">
<DIV class=3D"titlepage">
<DIV>
<DIV>
<H2 class=3D"title"><A =
name=3D"idp56821248"></A>Glossary</H2></DIV></DIV></DIV>
<P>      This glossary defines some of the terms used in this =
specification.    =20
</P>
<DL>
  <DT><A name=3D"term-bus-name"></A><SPAN class=3D"glossterm">Bus =
Name</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          The message bus maintains an association between names =
and       =20
    connections. (Normally, there's one connection per application.)  A  =
       =20
  bus name is simply an identifier used to locate connections. For       =
  =20
  example, the hypothetical <CODE=20
  class=3D"literal">com.yoyodyne.Screensaver</CODE>          name might =
be used to=20
  send a message to a screensaver from Yoyodyne          Corporation.  =
An=20
  application is said to <EM class=3D"firstterm">own</EM> a          =
name if the=20
  message bus has associated the application's connection          with =
the=20
  name.  Names may also have <EM class=3D"firstterm">queued          =
owners</EM>=20
  (see <A title=3D"Queued Name Owner" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-queu=
ed-owner">Queued=20
  Name Owner</A>).            The bus assigns a unique name to each =
connection, =20
             see <A title=3D"Unique Connection Name" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-uniq=
ue-name">Unique=20
  Connection Name</A>. Other names               can be thought of as=20
  "well-known names" and are               used to find applications =
that offer=20
  specific functionality.         </P>
  <P>          See <A title=3D"Bus names" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-bus">the=20
  section called =93Bus names=94</A> for details of          the syntax =
and naming=20
  conventions for bus names.         </P></DD>
  <DT><A name=3D"term-message"></A><SPAN =
class=3D"glossterm">Message</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          A message is the atomic unit of communication via the =
D-Bus      =20
     protocol. It consists of a <EM class=3D"firstterm">header</EM> and =
a         =20
   <EM class=3D"firstterm">body</EM>; the body is made up of           =
<EM class=3D"firstterm">arguments</EM>.=20
          </P></DD>
  <DT><A name=3D"term-message-bus"></A><SPAN class=3D"glossterm">Message =

  Bus</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          The message bus is a special application that forwards    =
      =20
  or routes messages between a group of applications          connected =
to the=20
  message bus. It also manages            <EM =
class=3D"firstterm">names</EM> used=20
  for routing          messages.         </P></DD>
  <DT><A name=3D"term-name"></A><SPAN =
class=3D"glossterm">Name</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          See <A title=3D"Bus Name" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-bus-=
name">Bus=20
  Name</A>. "Name" may             also be used to refer to some of the =
other=20
  names            in D-Bus, such as interface names.         </P></DD>
  <DT><A name=3D"namespace"></A><SPAN =
class=3D"glossterm">Namespace</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          Used to prevent collisions when defining new interfaces, =
bus=20
  names          etc. The convention used is the same one Java uses for =
defining=20
           classes: a reversed domain name.          See <A title=3D"Bus =
names"=20
  class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-bus">the=20
  section called =93Bus names=94</A>,           <A title=3D"Interface =
names" class=3D"xref"=20
  =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-interface">the=20
  section called =93Interface names=94</A>,           <A title=3D"Error =
names" class=3D"xref"=20
  =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-names-error">the=20
  section called =93Error names=94</A>,           <A title=3D"Valid =
Object Paths"=20
  class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#message-p=
rotocol-marshaling-object-path">the=20
  section called =93Valid Object Paths=94</A>.         </P></DD>
  <DT><A name=3D"term-object"></A><SPAN =
class=3D"glossterm">Object</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          Each application contains <EM =
class=3D"firstterm">objects</EM>,=20
  which have           <EM class=3D"firstterm">interfaces</EM> and       =
    <EM=20
  class=3D"firstterm">methods</EM>. Objects are referred to by a name,   =
      =20
  called a <EM class=3D"firstterm">path</EM>.         </P></DD>
  <DT><A name=3D"one-to-one"></A><SPAN =
class=3D"glossterm">One-to-One</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          An application talking directly to another application, =
without=20
  going          through a message bus. One-to-one connections may be =
"peer to=20
  peer" or          "client to server." The D-Bus protocol has no =
concept of=20
  client          vs. server after a connection has authenticated; the =
flow of=20
  messages          is symmetrical (full duplex).         </P></DD>
  <DT><A name=3D"term-path"></A><SPAN =
class=3D"glossterm">Path</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          Object references (object names) in D-Bus are organized =
into a   =20
        filesystem-style hierarchy, so each object is named by a path. =
As in    =20
       LDAP, there's no difference between "files" and "directories"; a =
path    =20
       can refer to an object, while still having child objects below =
it.       =20
   </P></DD>
  <DT><A name=3D"term-queued-owner"></A><SPAN class=3D"glossterm">Queued =
Name=20
  Owner</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          Each bus name has a primary owner; messages sent to the =
name go=20
  to the          primary owner. However, certain names also maintain a =
queue of=20
           secondary owners "waiting in the wings." If the primary owner =

  releases          the name, then the first secondary owner in the =
queue=20
  automatically          becomes the new owner of the name.         =
</P></DD>
  <DT><A name=3D"term-service"></A><SPAN =
class=3D"glossterm">Service</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          A service is an executable that can be launched by the =
bus=20
  daemon.          Services normally guarantee some particular features, =
for=20
  example they          may guarantee that they will request a specific =
name=20
  such as          "com.example.Screensaver", have a singleton object    =
     =20
  "/com/example/Application", and that object will implement the         =
=20
  interface "com.example.Screensaver.Control".         </P></DD>
  <DT><A name=3D"term-service-description-files"></A><SPAN=20
  class=3D"glossterm">Service Description Files</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          ".service files" tell the bus about service applications =
that can=20
  be          launched (see <A title=3D"Service" class=3D"xref" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#term-serv=
ice">Service</A>).=20
  Most importantly they          provide a mapping from bus names to =
services=20
  that will request those            names when they start up.         =
</P></DD>
  <DT><A name=3D"term-unique-name"></A><SPAN class=3D"glossterm">Unique =
Connection=20
  Name</SPAN></DT>
  <DD class=3D"glossdef">
  <P>          The special name automatically assigned to each =
connection by the=20
           message bus. This name will never change owner, and will be =
unique   =20
        (never reused during the lifetime of the message bus).          =
It will=20
  begin with a ':' character.         </P></DD></DL></DIV>
<DIV class=3D"footnotes"><BR>
<HR style=3D"width: 100px; text-align: left; margin-left: 0px;">

<DIV class=3D"footnote" id=3D"ftn.idp56106992">
<P><A class=3D"para" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp561069=
92"><SUP=20
class=3D"para">[1] </SUP></A>Lockfiles are used instead of real file     =
         =20
 locking <CODE class=3D"literal">fcntl()</CODE> because real locking     =
         =20
 implementations are still flaky on network               =20
filesystems.</P></DIV>
<DIV class=3D"footnote" id=3D"ftn.idp56598672">
<P><A class=3D"para" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp565986=
72"><SUP=20
class=3D"para">[2] </SUP></A>              The D-Bus reference =
implementation=20
actually honors the                <CODE =
class=3D"literal">$(localstatedir)</CODE>=20
configure option               for this address, on both client and =
server side.=20
            </P></DIV>
<DIV class=3D"footnote" id=3D"ftn.idp56602880">
<P><A class=3D"para" =
href=3D"http://dbus.freedesktop.org/doc/dbus-specification.html#idp566028=
80"><SUP=20
class=3D"para">[3] </SUP></A>              The system bus is =
security-sensitive=20
and is typically executed              by an init system with a clean=20
environment. Its launch helper              process is particularly=20
security-sensitive, and specifically              clears its own =
environment.   =20
         </P></DIV></DIV></DIV></BODY></HTML>
